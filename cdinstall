#! /bin/sh
#

# Licensed Materials - Property of IBM
#
# Connect:Direct(R) for UNIX
#
# (C) Copyright IBM Corp. 1992, 2016 All Rights Reserved.
#
# US Government Users Restricted Rights - Use, duplication or disclosure
# restricted by GSA ADP Schedule Contract with IBM Corp.

#================================================================
#
# Connect:Direct(R)
# COPYRIGHT (C) 1983, 2014  Sterling Commerce, Inc.
#
# This material is the confidential trade secret and proprietary
# information of Sterling Commerce, Inc. and/or its subsidiaries.
# It may not be reproduced, used, sold, or transferred to any
# third party without the prior written consent of Sterling
# Commerce, Inc.  All rights reserved.
#
# Use, duplication, or disclosure by the Government is subject
# to restrictions as set forth in subparagraph (c)(1)(ii) of
# the Rights in Technical Data and Computer Software clause at
# FAR 52.227-7013.
#
#              	    Connect:Direct for UNIX
#
# Module function: Connect:Direct for UNIX installation script
#==============================================================
#<EOC_LABEL>

if [ -f "$cdai_optionsFile" ]; then
  . $cdai_optionsFile
fi 


PRODUCT_FULL_NAME="Connect:Direct"
PRODUCT_ABRV_NAME="CD"


SYSTEM_NAME="`uname -s`"

if [ X"$SYSTEM_NAME" = X"HP-UX" ]; then
    ARCH_NAME="`uname -m`"
else
    ARCH_NAME="`uname -p`"
fi

DISKUTIL="etc/diskfree "
REMOTE_SHELL=/usr/ucb/rsh
FREE_DISK=/bin/df
if [ -f /usr/bin/nawk ]
then
	NAWK=nawk
else
	NAWK=awk
fi
KBYTES=
HOSTNAME_CMD=`hostname`

if [ "$cdai_installCmd" = "" ]; then
	if [ "`type clear`" = 'clear not found' ]; then
		CLEAR='tput clear'
	else
		CLEAR=clear
	fi
else
  CLEAR="echo"
fi


#==============
# Product Parameters
#==============
PROD_VERSION=4.2.0.4
NDMVER=etc/cdver	# utility script to determine version number
DESTINATION=cdunix	# default destination directory

INSTALLING_VER=`echo $PROD_VERSION | cut -d"." -f1`
INSTALLING_REL=`echo $PROD_VERSION | cut -d"." -f2`
INSTALLING_MOD=`echo $PROD_VERSION | cut -d"." -f3`
INSTALLING_FIX=`echo $PROD_VERSION | cut -d"." -f4`

#==============
# Product Component Sizes
#==============
CLIDISKREQ=17174
SVCDISKREQ=32394
FADISKREQ=339136
SPINSTALLDISKREQ=325150
TOTAL_DISKREQ=33415

PATH=/bin:/usr/bin:/usr/ucb:/usr/bsd:/usr/sbin:${PATH}
PROMPT1=

SPVERIFY__SERVER_HAS_BEEN_UNPACKED=false
SPVERIFY__OLD_SECP_INSTL_FOUND=false
SPVERIFY__SECP_HAS_BEEN_UNPACKED=false

#==============
# OS Parameters
#==============

#
# By default, uname -s returns the system type (Solaris, AIX, etc).
# However, the output of uname -s is configurable, and some systems
# have it set so that uname -s will output the TCP hostname, rather
# than the system type.  Therefore, if we did not get a valid
# system type from uname -s, we must ask the user for it.
#

case $SYSTEM_NAME in
	Linux* | AIX* | HP-UX* | SunOS* | OSF1* )
		echo
		;; # We got a valid OS type back from uname -s

	*)
		# uname -s not returning valid system type, so prompt them for it.
		$CLEAR
		echo "The system type $SYSTEM_NAME returned by uname -s is not recognized."
		while [ "$VALID_SYSNAME" != "TRUE" ]
		do
			echo "Please choose your system type from the following list:"
			echo
			echo "1. IBM AIX                  4. HP Tru64"
			echo "2. HP_UX                    5. Linux"
			echo "3. SunOS/Solaris"
			echo
			read response
			VALID_SYSNAME="TRUE"
			case $response in
				1)
					SYSTEM_NAME="AIX" ;;                        # IBM AIX
				2)
					SYSTEM_NAME="HP-UX" ;;                      # HP_UX
				3)
					SYSTEM_NAME="SunOS" ;;                      # SunOS / Solaris
				4)
					SYSTEM_NAME="OSF1" ;;                       # Compaq Tru64
				5)
					SYSTEM_NAME="Linux" ;;                      # Linux
				*)
					$CLEAR;echo "Invalid response. "            # Try again
					VALID_SYSNAME="FALSE" ;;
			esac
                  if [ "$cdai_installCmd" != "" ]; then
                    if [ "$VALID_SYSNAME" = "FALSE" ]; then
                      echo "\n### Invalid system name entered."
                      exit 101
                    fi
                  fi
		done
		echo "Using system type $SYSTEM_NAME."
		;;
esac


case "$SYSTEM_NAME" in

	Linux)
		REMOTE_SHELL=/usr/bin/rsh
		OS_NAME=Linux
		FREE_DISK="/bin/df -k"
		DISKUTIL="etc/diskfree "
		archName=`uname -m`
		# 3.8 secure+ integration
		SECURE_FEATURES=1
                # SNMP not supported on this platform.  Clear out variable.
                OPTIONAL_FEATURES=
		;;

	HP-UX)
		REMOTE_SHELL=/usr/bin/remsh
		OS_NAME=HP_UX
		FREE_DISK=/usr/bin/bdf
		SNA_LU62=BLKLU62
		DISKUTIL="etc/diskfree "
		archName=`uname -m`
		if [ "$archName" = "ia64" ]
                  then  # SNMP not supported on Itanium.
		    OPTIONAL_FEATURES=
                  else
		    OPTIONAL_FEATURES=1
		fi
		SECURE_FEATURES=1
		;;

	UNIX_SV)
		#NCR / AT&T
		REMOTE_SHELL=/bin/remsh
		KBYTES=-k
		OS_NAME=SVR4
		ARCHITECTURE=NCR/3433/386/486/MC
		NCRSNA_ATT=YES
		SNA_LU62=BLKLU62
		OPTIONAL_FEATURES=1
		;;

	AIX)
		REMOTE_SHELL=/usr/bin/rsh
		OS_NAME=AIX
		KBYTES=-k
		ARCHITECTURE=IBM/RS6000
		SNA_LU62=IBM
		DISKUTIL="etc/diskfree "
		OPTIONAL_FEATURES=1
		# 3.8 for secure+ integration
		SECURE_FEATURES=1
		;;

	SunOS)
		SUN_REL="`uname -r |awk '{S=substr($1,1,1)} {print S}'`"
		if [ "`uname -p`" = "sparc" ]; then
			if [ "$SUN_REL" -gt 4 ]; then
				OS_NAME=SunSparc
				ARCHITECTURE=SUN/SPARC
				KBYTES=-k
				SNA_LU62=BLKLU62
				DISKUTIL="etc/diskfree "
				OPTIONAL_FEATURES=1
				# 3.8 for secure+ integration
				SECURE_FEATURES=1
			else
				OS_NAME=SunOS
				ARCHITECTURE=SUN
			fi
		else
			OS_NAME=Solaris
			ARCHITECTURE='x86'
			OPTIONAL_FEATURES=
			SECURE_FEATURES=1
			KBYTES=-k
			DISKUTIL="etc/diskfree "
		fi
		;;

	ULTRIX)
		# DEC Ultrix
		OS_NAME=Ultrix
		ARCHITECTURE=DEC/RISC
		;;

	OSF1)
		# DEC ALPHA/OSF1 (Digital UNIX)
		OS_NAME=OSF/1
		KBYTES=-k
		ARCHITECTURE=DEC/ALPHA
		# 3.8 for secure+ integration for cpqtru64
		SECURE_FEATURES=1
                # SNMP not supported on this platform.  Clear out variable.
                OPTIONAL_FEATURES=
		;;

	dgux)
		# DG AViiON
		OS_NAME=DG/UX
		KBYTES=-k
		ARCH="`uname -p |awk '{S=substr($1,1,7)} {print S}'`"
		if [ "$ARCH" = mc88100 ]; then
			ARCHITECTURE=DG/mc88100
		else
			ARCHITECTURE=DG/Intel
		fi
		;;

	UNIX_System_V)
		# Stratus FTX
		REMOTE_SHELL=/bin/rsh
		OS_NAME=UNIX_System_V
		KBYTES=-k
		ARCHITECTURE='Continuum Model 412 PA-RISC'
		;;

	SCO_SV)
		# SCO UNIX
		OS_NAME='SCO UNIX'
		FREE_DISK=/bin/df
		KBYTES=-Pk
		ARCHITECTURE='Intel x86'
		SCO=YES
		REMOTE_SHELL=/usr/bin/rcmd
		;;

	S*DC*OSx)
		# Pyramid
		REMOTE_SHELL=/usr/bin/rsh
		OS_NAME=SMP_DC.OSx
		FREE_DISK=/usr/ucb/df
		ARCHITECTURE=Pyramid/r3000
		;;

	SINIX-N)
		# Siemens Nixdorf SINIX
		REMOTE_SHELL=/usr/bin/rsh
		OS_NAME=SINIX-N
		KBYTES=-k
		ARCHITECTURE='Siemens Nixdorf R4000'
		SNA_LU62=BLKLU62
		;;

	*)
		echo "ERROR: Undefined target name $SYSTEM_NAME"
		exit 1
		;;

esac

# Blue Wash.  Setting this var to "1" in the switch/case above triggered SNMP
# feature support.  Set it completely off here as SNMP is now removed.
OPTIONAL_FEATURES=

PID="!@$PRODUCT_FULL_NAME for UNIX Version $VERSION $ARCHITECTURE $OS_NAME"

# File Agent build date
NUFA_build_date="20150831"

RSHELL=$REMOTE_SHELL
PATH=/bin:/usr/bin:/usr/ucb:/usr/bsd:/usr/sbin:${PATH}
PROMPT1=
#=============================================================#
#                 functions                                   #
#=============================================================#

#=============================================================================
# func_populate_existing_version_vars ()
#
# Populate our VRMF style version number variables for any version ALREADY
# installed.  Note, if we encounter an old-style non-dot delimited value like
# 3701 or 3800 then that value is placed in $INSTLD_VER and the
# other vars are left empty.
#=============================================================================

INSTLD_VER=""
INSTLD_REL=""
INSTLD_MOD=""
INSTLD_FIX=""
INSTLD_IFix=""
INSTLD_PRODVER=""
# INSTLD_PRODVER will contain the entire output of etc/cdver if successful.
func_populate_existing_version_vars ()
{
    # Careful, older versions of cdver printed multiple lines and/or had the
    # actual version number in different columns of the string.

    if [ -x $DESTINATION_PATH/etc/cdver ]; then
        INSTLD_PRODVER=`$DESTINATION_PATH/etc/cdver | grep "Version "`
        if [ $? -ne 0 ]; then
            return $?
        fi
    else
        return 2
    fi

    RC=0
    CAPTURE_NEXT=false
    POP_VER_ORIG_IFS="$IFS"
    IFS=" .,_"
        for i in $INSTLD_PRODVER
        do
            if [ X"$i" = X"Version" ]; then
                CAPTURE_NEXT=true
                # Next loop around token will presumably start our version.
                continue
            fi

            if $CAPTURE_NEXT; then
                if [ -z "$INSTLD_VER" ]; then
                    INSTLD_VER="$i"
                    # Check is integer and if is old or new style version number:
                    case $INSTLD_VER in
                        [0-9][0-9][0-9][0-9]) break;;  # Old style version number.

                        [0-9]|[0-9][0-9])  continue;;  # One or two digit new style
                                                       # VRMF number (the V part)
                        *) RC=1
                           INSTLD_VER=""
                           break;;           # Not a number or format we recognize.
                    esac
                elif [ -z "$INSTLD_REL" ]; then
                    INSTLD_REL="$i"
                elif [ -z "$INSTLD_MOD" ]; then
                    INSTLD_MOD="$i"
                elif [ -z "$INSTLD_FIX" ]; then
                    INSTLD_FIX="$i"
                else
                    if [ X"$i" = X"Build" ]; then
                        INSTLD_IFix="0"
                    else
                        INSTLD_IFix=`expr "$i" : 'iFix0*\(.*\)'`
                    fi
                    break
                fi
            fi
        done
    IFS="$POP_VER_ORIG_IFS"

    return $RC
} # END func_populate_existing_version_vars()

func_is_existing_newer ()
{
    if func_populate_existing_version_vars; then

        NEWER_INSTALLED=false

        # First check if existing version is old style "3701" or "3800", etc.
        if   [ $INSTLD_VER -gt 999 ]; then
        	    NEWER_INSTALLED=false
        elif [ $INSTLD_VER -gt $INSTALLING_VER ]; then
                NEWER_INSTALLED=true
        elif [ $INSTLD_VER -eq $INSTALLING_VER ] &&
             [ $INSTLD_REL -gt $INSTALLING_REL ]; then
                NEWER_INSTALLED=true
        elif [ $INSTLD_VER -eq $INSTALLING_VER ] &&
             [ $INSTLD_REL -eq $INSTALLING_REL ] &&
             [ $INSTLD_MOD -gt $INSTALLING_MOD ]; then
                NEWER_INSTALLED=true
        elif [ $INSTLD_VER -eq $INSTALLING_VER ] &&
             [ $INSTLD_REL -eq $INSTALLING_REL ] &&
             [ $INSTLD_MOD -eq $INSTALLING_MOD ] &&
             [ $INSTLD_FIX -gt $INSTALLING_FIX ]; then
                NEWER_INSTALLED=true
        fi

        if $NEWER_INSTALLED; then
            return 0
        else
            return 1
        fi
    else
        return 1
    fi
}


#============
# User has asked to exit the Installation. Add verification logic here in
# case they're exiting too early and have left the product in an unstable
# state.  One in which the product may not even run anymore.
#============
verify_is_safe_to_exit() #
{
    # Verify if a mixed version of the Server product and the Secure+ product
    # exist.
    # If the user exits a server upgrade, and did not update Secure+ too, then
    # the product won't start.
    # If they had a previous install, but said "N" to upgrade and did a Server
    # overlay, then they could still be in the same situation. The old Secure+
    # files are still out there.

    if $SPVERIFY__OLD_SECP_INSTL_FOUND     &&
       $SPVERIFY__SERVER_HAS_BEEN_UNPACKED &&
       [ $SPVERIFY__SECP_HAS_BEEN_UNPACKED = "false" ]; then
        echo
        echo "WARNING!!! The $PRODUCT_FULL_NAME for UNIX server product has been"
        echo "upgraded however, the Secure+ installation has NOT been"
        echo "properly updated. The $PRODUCT_FULL_NAME server will not run in"
        echo "this state."
        echo
        echo "Are you sure you want to exit without upgrading the Secure+"
        echo "component?"
        echo
        echo 'Would you like to return to the installation menu and complete'
        echo_nn "the Secure+ upgrade procedure?:[Y/n]"; yes_or_no
        if [ "$YESNO" = "n" ]; then
            echo
            echo "PRODUCT_FULL_NAME for UNIX Installation procedure exited. Secure+"
            echo "upgrade conversion procedure NOT completed."
            echo
            exit 2
        fi
    else
        echo
        echo "$PRODUCT_FULL_NAME for UNIX Installation procedure exited."
        exit
    fi

    return 0
}

#============
# User did a Ctrl + c to KILL the Installation. Add verification logic here
# in case they're exiting too early and have left the product in an unstable
# state.  One in which the product may not even run anymore.
#============
verify_is_safe_to_exit_trap() #
{
    # Verify if a mixed version of the Server product and the Secure+ product
    # exist.
    # If the user exits a server upgrade, and did not update Secure+ too, then
    # the product won't start.
    # If they had a previous install, but said "N" to upgrade and did a Server
    # overlay, then they could still be in the same situation. The old Secure+
    # files are still out there.

    if $SPVERIFY__OLD_SECP_INSTL_FOUND     &&
       $SPVERIFY__SERVER_HAS_BEEN_UNPACKED &&
       [ $SPVERIFY__SECP_HAS_BEEN_UNPACKED = "false" ]; then
        echo
        echo
        echo "Incomplete installation!"
        echo
        echo "WARNING!!! The $PRODUCT_FULL_NAME for UNIX server product has been"
        echo "upgraded however, the Secure+ installation has NOT been"
        echo "properly updated. The $PRODUCT_FULL_NAME server will not run in"
        echo "this state."
        echo
        echo "At your convenience, please re-run the installation program"
        echo "and choose the option to install the Secure+ component."
        echo
        echo "$PRODUCT_FULL_NAME for UNIX Installation procedure exited."
        echo

        exit 2
    fi
}

#============
# determine solaris SNA stack
#============
solaris_sna_select() # start of solaris_sna_select
{
	if [ -n "$NEEDSNACHECK" -a `uname` = "SunOS" ]; then

		snarc=0

		echo
		echo_nn "Is your $PRODUCT_FULL_NAME installation configured to use SNA?:[Y/n]"; yes_or_no

		if [ "$YESNO" = "y" ]
		then
			snarc=1
			echo '  Please choose the SNA stack running on this system.'
			echo
			echo '  (1) SunLink.'
			echo '  (2) Brixton.'
			echo '  (3) SNAP-IX.'
			echo
			PROMPT='Enter your choice:[3]'
			DEFAULT=3
			VALUE_TYPE=
			RC=0
			while [ $RC -eq 0 ]
			do
				get_value
				if [ -z "$VALUE" ]
				then
					VALUE="$DEFAULT"
					RC=1
				elif [ $VALUE -ge 1 -a $VALUE -le 3 ]
				then
					RC=1
				else
					echo ' Please enter valid value'
				fi
			done

			snachoice="$VALUE"

			SNAFILE=${DESTINATION_PATH}/ndm/lib/libcdsna.so
			BRXSNAFILE=${DESTINATION_PATH}/ndm/lib/libcdbrxsna.so
			SNPSNAFILE=${DESTINATION_PATH}/ndm/lib/libcdsnpsna.so

			if [ $snachoice -eq 1 -o $snachoice -eq 2 ]
			then
				cp -f $BRXSNAFILE $SNAFILE
				if [ $? -ne 0 ]
				then
					echo
					echo "================================================================"
					echo "WARNING!!!  The Brixton SNA library was not properly configured."
					echo "Please insure that the library is copied to the lib/libcdsna.so,"
					echo "or $PRODUCT_FULL_NAME product will not function properly.       "
					echo "================================================================"
					echo
				fi
			fi

			if [ $snachoice -eq 3 ]
			then
				cp -f $SNPSNAFILE $SNAFILE
				if [ $? -ne 0 ]
				then
					echo
					echo "================================================================"
					echo "WARNING!!!  The SNAP-IX SNA library was not properly configured."
					echo "Please insure that the library is copied to the lib/libcdsna.so,"
					echo "or $PRODUCT_FULL_NAME product will not function properly.       "
					echo "================================================================"
					echo
				fi
			fi
		fi
	fi
} # end of solaris_sna_select

#============
# echo without new line
#============
echo_nn() # start of echo_nn
{
	if [ "${V_echo}" = TRUE ]; then
		echo $1 \\c
	else
		echo -n $1
	fi
} # end of echo_nn

#============
# Get y/n answer from the user
#============
yes_or_no() # function start
{
	read YESNO
	if [ "$YESNO" = "y" -o "$YESNO" = "Y" ]; then
		YESNO=y
	elif [ "$YESNO" = "n" -o "$YESNO" = "N" ]; then
		YESNO=n
	elif [ "$YESNO" = "" ]; then
          if [ "$cdai_installCmd" != "" ]; then
            echo "\n### cdinstall.yes_or_no: y or n must be entered for automated installation. input=$YESNO"
            exit 102
          else
            YESNO="y"
          fi
        else
		echo_nn 'Please answer with "y" or "n":'
		yes_or_no
	fi

	if [ "$cdai_installCmd" != "" ]; then
		echo_nn " $YESNO"
	fi
}
#============
# display help messages
#============
display_help_message() # function start
{
	echo
	echo "****"
	echo "    $HELP_MESSAGE"
	echo
}
#============
# Get value from user
#============
get_value() # function start
{

	if [ "$1" != SILENT ]; then
		echo
		if [ -n "$PROMPT1" ]; then
			echo $PROMPT1
			PROMPT1=
		fi
		if [ -n "$PROMPT2" ]; then
			echo $PROMPT2
			PROMPT2=
		fi
		if [ -n "$PROMPT" ]; then
			echo $PROMPT
		fi
	fi

	read VALUE
	if [ "$VALUE" = "?" ]; then
		display_help_message 
		get_value
	fi
        if [ "$cdai_installCmd" != "" ]; then
          if [ "$VALUE" = "" ]; then
            echo "### No value read in get_value() function. input=$VALUE"
            exit 103
          fi
        fi

	if [ "$cdai_installCmd" != "" ]; then
                echo_nn " $VALUE"
        fi

}

#=============
# For an upgrade, verify the "Product Name" strings added to the initparm.cfg
# and ndmapi.cfg are the same value seen this installation "media".
# If this is an upgrade or patch, AND is also for a preexisting White
# Labeled installation, then the product name in the installation media
# must match the product name in this preexisting installation.
# Alternately, if this installation media has been White Labeled, but the
# preexisting installation is not White Labeled, the installation cannot
# continue because we can't white label an "existing" installation via upgrade.
#=============
func_prod_names_match_or_exit () #
{
    fail_this_wl_upgrade=false

    # Note that the new prod name and prod abbreviation strings are NOT added to
    # the cfg files in a new installation that is NOT white labeled. Doing so
    # is fine, should we ever decide to start adding them. But we don't do it
    # currently just so nothing has changed for anyone else.
    # The PRODUCT_FULL_NAME and PRODUCT_ABRV_NAME variables you see below are
    # defined at the top of this file.  If "this" media is white labeled then
    # they are no longer set to "Connect:Direct", etc.

    cd "$DESTINATION_PATH"
    if [ ! -d ndm/cfg  ]; then
        # Not an upgrade.
        return 0
    fi

    for i in `find "ndm/cfg" \( -name "initparm.cfg" -o -name "ndmapi.cfg" \) -print`
    do
        if [ `basename "$i"` = "initparm.cfg"  ]; then
            installed_prod_name=`func_fetch_cfg_parm_value "ndm.prod" "name" "$i"`
            if [ -n "$installed_prod_name" ] &&
               [ X"$installed_prod_name" != X"$PRODUCT_FULL_NAME" ]; then
                fail_this_wl_upgrade=true
            elif [ -z "$installed_prod_name" ] &&
               [ X"$PRODUCT_FULL_NAME" != X"Connect:Direct" ]; then
                # Cannot white label an "existing" non-white labeled installation via upgrade
                fail_this_wl_upgrade=true
            fi

            installed_prod_abrv=`func_fetch_cfg_parm_value "ndm.prod" "abrv" "$i"`
            if [ -n "$installed_prod_abrv" ] &&
               [ X"$installed_prod_abrv" != X"$PRODUCT_ABRV_NAME" ]; then
                fail_this_wl_upgrade=true
            elif [ -z "$installed_prod_abrv" ] &&
               [ X"$PRODUCT_ABRV_NAME" != X"CD" ]; then
                fail_this_wl_upgrade=true
            fi

            if $fail_this_wl_upgrade; then
                break
            fi
        fi

        if [ `basename "$i"` = "ndmapi.cfg"  ]; then
            installed_prod_name=`func_fetch_cfg_parm_value "cli.parms" "prod.name.full" "$i"`
            if [ -n "$installed_prod_name" ] &&
               [ X"$installed_prod_name" != X"$PRODUCT_FULL_NAME" ]; then
                fail_this_wl_upgrade=true
            elif [ -z "$installed_prod_name" ] &&
               [ X"$PRODUCT_FULL_NAME" != X"Connect:Direct" ]; then
                # Cannot white label an "existing" non-white labeled installation via upgrade
                fail_this_wl_upgrade=true
            fi

            installed_prod_abrv=`func_fetch_cfg_parm_value "cli.parms" "prod.name.abrv" "$i"`
            if [ -n "$installed_prod_abrv" ] &&
               [ X"$installed_prod_abrv" != X"$PRODUCT_ABRV_NAME" ]; then
                fail_this_wl_upgrade=true
            elif [ -z "$installed_prod_abrv" ] &&
               [ X"$PRODUCT_ABRV_NAME" != X"CD" ]; then
                fail_this_wl_upgrade=true
            fi

            if $fail_this_wl_upgrade; then
                break
            fi
        fi
    done


    if $fail_this_wl_upgrade; then
        # To make the error message clearer, if an attempt was made to install white
        # labeled "media" over an un-labeled existing installation, use default names
        if [ -z "$installed_prod_name" ];then
            installed_prod_name='Connect:Direct'
        fi
        if [ -z "$installed_prod_abrv" ];then
            installed_prod_abrv='CD'
        fi

        printf '\n\nERROR:  Installation media product name or abbreviation does not match the
        existing installation found in %s\n\n' "$DESTINATION_PATH/$i"

        printf 'Product name in installation media:     %s\n'   "$PRODUCT_FULL_NAME"
        printf 'Product name in existing installation:  %s\n\n' "$installed_prod_name"

        printf 'Product abbreviation in installation media:     %s\n'   "$PRODUCT_ABRV_NAME"
        printf 'Product abbreviation in existing installation:  %s\n\n' "$installed_prod_abrv"

        printf 'Upgrading with conflicting product names is not supported.\n\n'
        exit 2
    else
        return 0
    fi
} # END func_prod_names_match_or_exit ()


#=============
# Parse any configuration file to obtain the value of a given parameter.
# For example, to obtain the value of "ckpt.interval" from an initparm.cfg
# file, call func_fetch_cfg_parm_value () like so:
#   func_fetch_cfg_parm_value "copy.parms" "ckpt.interval" "ndm/cfg/initparm.cfg"
#
# Note that func_fetch_cfg_parm_value () might not print any value upon
# exit.  Parameters values in the configuration files are often absent
# or explicitly set to an empty string.  That is not an error.
# Therefore, func_fetch_cfg_parm_value () will only exit with a failure
# if it was unable to open and read the file provided in $3, or if
# insufficient arguments were supplied.
#=============
func_fetch_cfg_parm_value () #
{
    cfg_node_entry="$1"
    cfg_parm_entry="$2"
    cfg_file_name="$3"

    if [ $# -ne 3 ]; then
        echo "ERROR: Incorrect number of arguments supplied to func_fetch_cfg_parm_value ()"
        return 2
    fi

    if [ ! -r "$cfg_file_name" ]; then
        echo "ERROR:  The file name \"$cfg_file_name\" does not exist,"
        echo "        is a directory, or read permission is denied."
        return 2
    fi


    $NAWK '
    {
        sub(/^[ \t]+/, "")  # leading white space

        if ($1 == the_node) { found_node=1 }

        if (found_node)
        {
            sub(/[ \t]+$/, "")  # trailing white space

            # Obtain and join a complete record.

            if (substr($0, length($0), 1) == ":")
            {
                # We have reached the end of this full node record entry.
                # Find the sub-parm, if its even there, and exit.
                $0 = node_entry$0
                node_entry = ""

                for (i = 1; i <= NF; i++)
                {
                    split($i, this_parm, "=")

                    if (this_parm[1] == the_parm)
                    {
                        sub(/^[ \t]+/, "", this_parm[2])
                        sub(/[ \t]+$/, "", this_parm[2])
                        print this_parm[2]
                        exit 0
                    }
                }
                exit 0          # Comment out "exit" and uncomment "found_node"
                # found_node=0  # to process for duplicate records in the file.
            }
            else
            {
                sub("\\\\$", "")  # Ditch the trailing \, join, continue.
                node_entry = node_entry$0
                next
            }
        }
    }' FS=":" the_node="$cfg_node_entry" the_parm="$cfg_parm_entry" "$cfg_file_name"

    return 0
} # END func_fetch_cfg_parm_value ()


#=============
# Selecting the destination directory 
#=============
set_dest_dir()	# start of set_dest_dir
{
	# Parms
	# none

	while [ true ]; do
		PROMPT1="Enter the FULL path of the $PRODUCT_FULL_NAME for UNIX $PROD_VERSION installation directory."
		PROMPT="You can use $HOME to shorten the name:[$HOME/$DESTINATION]"
		HELP_MESSAGE="The destination directory is the the directory under which all $PRODUCT_FULL_NAME for UNIX files are installed. You must have write permission for this directory."

		get_value

		if [ -z "$VALUE" ]; then
			DESTINATION_PATH=$HOME/$DESTINATION
		else
			DESTINATION_PATH=`/bin/sh -c "echo $VALUE "`
		fi

		# Check for overwriting existing files and directories
		if [ -f "$DESTINATION_PATH" ]; then     # file exists
			echo
			echo "    "\"$DESTINATION_PATH\" : File exists
			echo
			if [ "$cdai_installCmd" != "" ]; then
                        	exit 104
			fi
			echo_nn "Do you want to overwrite ${DESTINATION_PATH}?:[Y/n]"; yes_or_no
			if [ "$YESNO" = "y" ]; then
				rm -f $DESTINATION_PATH
				mkdir -p $DESTINATION_PATH
				break
			fi
		elif [ -d "$DESTINATION_PATH" -a "$cdai_installCmd" = "" ]; then   # directory exists
			echo
			echo WARNING: \"$DESTINATION_PATH\" : Directory exists
			echo
			echo "Files in $DESTINATION_PATH could be overwritten by the"
			echo_nn "installation. Do you want to continue?:[Y/n]"; yes_or_no
			if [ "$YESNO" = "y" ]; then
                # For White label, make sure the prod name in the media matches the
                # prod name in any existing installation (and vice versa) BEFORE we
                # unpack all the binaries and overlay.
                func_prod_names_match_or_exit
				break;
			fi
		else
			echo
			echo "You have chosen $DESTINATION_PATH"
			echo_nn "as destination directory. Please confirm it:[Y/n]"; yes_or_no
			if [ "$YESNO" = "y" ]; then
				mkdir -p $DESTINATION_PATH
                func_prod_names_match_or_exit
				break
			fi
		fi
	done

	Install_option=

	ls -dal $DESTINATION_PATH.CDBackup.*.tar > /dev/null 2>&1
	Backup_not_detected=$?
	if [ $Backup_not_detected -eq 0 -a "$cdai_installCmd" = "" ]
	then
		echo
		echo "Backup file(s) detected."
		echo
		echo "Would you like this procedure to restore a $PRODUCT_FULL_NAME for UNIX"
		echo "installation that was backed up at an earlier time?"
		echo
		echo "Caution:  if restoring $PRODUCT_FULL_NAME for UNIX earlier version,"
		echo "          existing processes in the tcq may encounter conversion error."
		echo "          They will need to be deleted and resubmitted."
		echo
		echo "Specify yes to continue with the restore procedure,"
		echo_nn "or no to do a new install or an upgrade:[Y/n]:";yes_or_no
		if [ "$YESNO" = "y" ]; then
			Install_option="RESTORE"
		fi
	fi

	if [ -z "$Install_option" -a "$cdai_installCmd" = "" ]
	then
		if [ -f "$DESTINATION_PATH/ndm/bin/direct" -o -f "$DESTINATION_PATH/ndm/bin/cdpmgr" -o -f "$DESTINATION_PATH/file_agent/fasat.jar" ]
		then
			echo
			echo "Installed components detected in this directory."
			echo

			if [ -d "$DESTINATION_PATH/ndm/secure+/nodes" ]; then
			    # We'll check this later if the user exits a server upgrade, and did not
			    # update Secure+ too.  The product won't start if they don't update Secure+ too.
			    SPVERIFY__OLD_SECP_INSTL_FOUND=true
			fi

			if [ -f "$DESTINATION_PATH/etc/cdver" ]
			then
				if func_is_existing_newer; then
					echo "A newer version of $PRODUCT_FULL_NAME for UNIX is currently installed."
					echo
					echo "If you proceed, an older version of $PRODUCT_FULL_NAME, $PROD_VERSION, will"
					echo "be installed over the newer version, $INSTLD_VER.$INSTLD_REL.$INSTLD_MOD.$INSTLD_FIX.iFix$INSTLD_IFix" 
					echo
					echo_nn "Do you want to continue?:[Y/n]"
					yes_or_no
					if [ "$YESNO" = "n" ]
					then  
						# abort installation
						echo
						echo "$PRODUCT_FULL_NAME for UNIX installation aborted."
						exit 1
					else
						echo
						echo "Would you like this procedure to detect and overwrite your currently installed"
						echo "options with minimal interaction?"
						echo
						echo "If yes, your configuration files will be left in place and reused."
						echo
						echo "If no, you will proceed to the full installation menu with all available "
						echo "options listed for your selection.  You will have the option to either reuse "
						echo "your existing configuration files, or to purge and rebuild them."
						echo
						echo "Caution:  Since you are overwriting a later version of $PRODUCT_FULL_NAME"
						echo "          for UNIX, existing processes in the tcq may encounter conversion"
						echo "          errors.  You may need to delete and resubmit them."
						echo
						echo "Type y or press Enter to continue with the overwrite procedure, or"
						echo_nn "type n to run the full installation procedure:[Y/n]";yes_or_no
						if [ "$YESNO" = "y" ]
						then
							Install_option="UPGRADE"
						fi
					fi
				else
				    echo "Would you like this procedure to detect and upgrade your currently installed"
				    echo "components with minimal interaction?"
				    echo
				    echo "If yes, your configuration files will be left in place and reused."
				    echo
				    echo "If no, you will proceed to the full installation menu with all available "
				    echo "options listed for your selection.  You will have the option to either reuse "
				    echo "your existing configuration files, or to purge and rebuild them."
				    echo
				    echo "Caution:  If you are upgrading from a version of $PRODUCT_FULL_NAME for UNIX that"
				    echo "          is no longer supported, existing processes in the tcq may encounter"
				    echo "          conversion errors.  You may need to delete and resubmit them."
				    echo
				    echo "Type y or press Enter to continue with the upgrade procedure, or"
				    echo_nn "type n to run the full installation procedure:[Y/n]";yes_or_no
				    if [ "$YESNO" = "y" ]
				    then
					Install_option="UPGRADE"
				    fi
				fi
			else
				echo "Would you like this procedure to detect your installed options"
				echo "and update them with minimal interaction?"
				echo
				echo "Specify yes to continue with the update procedure,"
				echo_nn "or no to run the full installation procedure:[Y/n]";yes_or_no
				if [ "$YESNO" = "y" ]
				then
					Install_option="UPGRADE"
				fi
			fi
		fi
	fi

	if [ -z "$Install_option" -o "$cdai_installCmd" != "" ]
	then
		set_install_option
	fi

	#===============
	# export full path of destination dir for customization procedure
	#===============
	export DESTINATION_PATH
	export Install_option

} # end of set_dest_dir

set_install_option()	# start of set_install_option
{
	# Parms
	# none

	Install_option=

	while [ -z "$Install_option" ]; do
		$CLEAR
		echo
		echo "$PRODUCT_FULL_NAME for UNIX installation directory specified:"
		echo "$DESTINATION_PATH"
		echo
		echo
		echo "Please select one of the following installation options:"
		echo
		echo "  (1) $PRODUCT_FULL_NAME for UNIX Server and Client(CLI/API)"
		echo "  (2) $PRODUCT_FULL_NAME for UNIX Server"
		echo "  (3) $PRODUCT_FULL_NAME for UNIX Client(CLI/API)"
		echo "  (4) $PRODUCT_FULL_NAME for UNIX File Agent"

		# 3.8 for secure+ integration
		if [ -n "$SECURE_FEATURES" ]; then
			echo "  (5) $PRODUCT_FULL_NAME Secure+ Option for UNIX"
			if [ -n "$OPTIONAL_FEATURES" ]; then
				echo "  (6) $PRODUCT_FULL_NAME for UNIX SNMP Agent"
				echo "  (7) EXIT"
			else
				echo "  (6) EXIT"
			fi
		else

			if [ -n "$OPTIONAL_FEATURES" ]; then
				echo "  (5) $PRODUCT_FULL_NAME for UNIX SNMP Agent"
				echo "  (6) EXIT"
			else
				echo "  (5) EXIT"
			fi
		fi

		echo
		echo_nn "Enter your choice:[1]"
		read Install_option
		if [ -z "$Install_option" ]; then
			Install_option=1
		fi

		# Map user answer to fixed string name for case statement below

		# 3.8
		if [ -z "$SECURE_FEATURES" ]; then
			if [ -z "$OPTIONAL_FEATURES" ]; then
				case "$Install_option" in
					1)
						Install_option=SVR_CLI ;;
					2)
						Install_option=SVR_ONLY ;;
					3)
						Install_option=CLI_ONLY ;;
					4)
						Install_option=FILE_AGENT ;;
					5)
						Install_option=EXIT_SCRIPT ;;
					*)	
						echo
						echo "$Install_option is not a valid menu item.  Please select again."
						Install_option=
						;;
				esac
			else
				case "$Install_option" in
					1)
						Install_option=SVR_CLI ;;
					2)
						Install_option=SVR_ONLY ;;
					3)
						Install_option=CLI_ONLY ;;
					4)
						Install_option=FILE_AGENT ;;
					5)
						Install_option=SNMP_AGENT ;;
					6)
						Install_option=EXIT_SCRIPT ;;
					*)
						echo
						echo "$Install_option is not a valid menu item.  Please select again."
						Install_option=
						;;
				esac
			fi
		else
			if [ -z "$OPTIONAL_FEATURES" ]; then
				case "$Install_option" in
					1)
						Install_option=SVR_CLI ;;
					2)
						Install_option=SVR_ONLY ;;
					3)
						Install_option=CLI_ONLY ;;
					4)
						Install_option=FILE_AGENT ;;
					5)
						Install_option=SECURE_OPTION ;;
					6)
						Install_option=EXIT_SCRIPT ;;
					*)
						echo
						echo "$Install_option is not a valid menu item.  Please select again."
						Install_option=
						;;
				esac
			else
				case "$Install_option" in
					1)
						Install_option=SVR_CLI ;;
					2)
						Install_option=SVR_ONLY ;;
					3)
						Install_option=CLI_ONLY ;;
					4)
						Install_option=FILE_AGENT ;;
					5)
						Install_option=SECURE_OPTION ;;
					6)
						Install_option=SNMP_AGENT ;;
					7)
						Install_option=EXIT_SCRIPT ;;
					*)
						echo
						echo "$Install_option is not a valid menu item.  Plea
se select again."
						Install_option=
						;;
				esac
			fi
		fi
	done

} # end of set_install_option

#===============
# check if enough disk space is available
#===============
chk_free_disk()	# start of chk_free_disk
{
	RB=$2 # REQUESTED BYTES
	echo
	echo "Please wait while the procedure determines if there is"
	echo "sufficient disk space to complete this operation."
	echo
	if [ "$3" = "server" -o "$3" = "client" -o "$3" = "file_agent" -o "$3" = "backup" -o "$3" = "s+install" ]; then
		cd $1
		rm -f etc/diskfree*

		if [ -z "$Hostname" ]; then    # extract diskfree utility
			case "`uname -s`" in	
				Linux)
					cpio -idmVu $DISKUTIL < $Device 2>/dev/null;;
				*)
					cpio -cidmuB $DISKUTIL < $Device 2>/dev/null;;
			esac
		else
			case "`uname -s`" in	
				Linux)
					$RSHELL $Hostname -n "dd if=$Device ibs=5120" | cpio -idmVu $DISKUTIL 2>/dev/null;;
				*)
					$RSHELL $Hostname -n "dd if=$Device ibs=5120" | cpio -cidmuB $DISKUTIL 2>/dev/null;;
			esac
		fi
	fi # Extract diskfree for server or client
	echo
	if [ "X$1" = "X" ]; then
		LD_LIBRARY_PATH=./etc
		LIBPATH=./etc
		export LD_LIBRARY_PATH LIBPATH
		chmod u+x etc/diskfree

		$DESTINATION_PATH=.
		cd etc
	else
		LD_LIBRARY_PATH=${DESTINATION_PATH}/etc
		LIBPATH=${DESTINATION_PATH}/etc
		export LD_LIBRARY_PATH LIBPATH
		chmod u+x ${DESTINATION_PATH}/etc/diskfree
		cd ${DESTINATION_PATH}/etc
	fi
	# now execute diskfree with arguments passed
	${DESTINATION_PATH}/etc/diskfree $DESTINATION_PATH $RB

	# Check for return code from diskfree
	retcode=$?

	cd ..

	if [ $retcode -ne  0 ]; then
		rm -rf ${DESTINATION_PATH}/etc/diskfree
		if [ "$3" != "backup" ]
		then
			echo
			echo "There is insufficient disk space to complete this installation."
			if [ "$cdai_installCmd" != "" ]; then
				exit 113
			fi
			echo "Would you like to continue the install and choose another"
			echo_nn "destination directory?:[Y/n]"; yes_or_no
			if [ "$YESNO" = "n" ]; then  # abort installation
				exit 1
			else
				sleep 1
				set_device
				return 1
			fi
		else
			sleep 1
			return 1
		fi
	fi

	sleep 1
	return 0

}	#end of chk_free_disk

#===============
# Extract files from the tape and verify correct files are extracted
#===============
extract_n_verify()	# start of extract_n_verify
{
	client_or_server=$1
	case $1 in
		client)
			get_listfiles "client"
			filelist=$CLIFILES
			norm_filelist=$CLIFILES
			;;

		server)
			get_listfiles "server"
			filelist=$SVCFILES
			norm_filelist=$SVCFILES
			;;

		file_agent)
			get_listfiles "file_agent"
			filelist=$FAFILES
			norm_filelist=$FAFILES
			;;

		*)
			get_listfiles "server_and_cliapi"
			filelist=$TTLFILES
			norm_filelist=$TTLFILES
			;;
	esac

	#=============
	# Extracting files
	#=============
	echo
	echo "... Extracting $PRODUCT_FULL_NAME for UNIX $client_or_server files from the"
	echo "media. Actual time taken varies depending on the system configuration."

	for anyfile in $norm_filelist ; do
		if [ -f $anyfile -a "$anyfile" != "cdinstall" ]; then
			rm -f $anyfile
		fi
	done

	if [ "`uname -s`" = "OSF1" -a "$client_or_server" = "file_agent" ]; then
		chmod u+w etc/cdver etc/cdcust etc/tcq_convert etc/cfg_convert;
	fi

	# AIX's cpio command has a limit on how long of an argument list it
	# supports (2048 characters).  Break the file list into multiple,
	# smaller lists to avoid hitting this limit.
	SWIFT_LIST=""
	OTHER_LIST=""
	NDM_LIST=""
	SAV_LIST=""
	if [ "`uname -s`" = "AIX" ]; then
		for entry in ${filelist}
		do
			if echo ${entry} | grep -i SwiftNet > /dev/null
			then
				SWIFT_LIST="${SWIFT_LIST} ${entry}"
			else
				OTHER_LIST="${OTHER_LIST} ${entry}"
			fi
		done
		if [ -z "${SWIFT_LIST}" ]; then
			OTHER_LIST=""
			for entry in ${filelist}
			do
				if echo ${entry} | grep -i ndm > /dev/null
				then
					NDM_LIST="${NDM_LIST} ${entry}"
				else
					OTHER_LIST="${OTHER_LIST} ${entry}"
				fi
			done
		else
			# logic to break the OTHER_LIST to NDM_LIST and OTHER_LIST
			SAV_LIST=$OTHER_LIST
			OTHER_LIST=""
			for entry in ${SAV_LIST}
			do
				if echo ${entry} | grep -i ndm > /dev/null
				then
					NDM_LIST="${NDM_LIST} ${entry}"
				else
					OTHER_LIST="${OTHER_LIST} ${entry}"
				fi
			done
		fi
	fi

	if [ -z "$Hostname" ]; then  	 # local drive
		case "`uname -s`" in	
			Linux)
				cpio -iVdmu $filelist < $Device;;
			AIX)
				if [ -n "${OTHER_LIST}" ]; then
					cpio -civdmuB $OTHER_LIST < $Device
				fi
				if [ -n "${NDM_LIST}" ]; then
					cpio -civdmuB $NDM_LIST < $Device
				fi
				if [ -n "${SWIFT_LIST}" ]; then
					cpio -civdmuB $SWIFT_LIST < $Device
				fi
				;;
			*)
				cpio -civdmuB $filelist < $Device;;
		esac
	else
		case "`uname -s`" in	
			Linux)
				$RSHELL $Hostname -n "dd if=$Device ibs=5120" | cpio -iVdmu $filelist;;
			AIX)
				if [ -n "${OTHER_LIST}" ]; then
					$RSHELL $Hostname -n "dd if=$Device ibs=5120" | cpio -civdmuB $OTHER_LIST
				fi
				if [ -n "${NDM_LIST}" ]; then
					$RSHELL $Hostname -n "dd if=$Device ibs=5120" | cpio -civdmuB $NDM_LIST
				fi
				if [ -n "${SWIFT_LIST}" ]; then
					$RSHELL $Hostname -n "dd if=$Device ibs=5120" | cpio -civdmuB $SWIFT_LIST
				fi
				;;
			*)
				$RSHELL $Hostname -n "dd if=$Device ibs=5120" | cpio -civdmuB $filelist;;
		esac
	fi
	if [ "`uname -s`" = "OSF1" -a "$client_or_server" = "file_agent" ]; then
		chmod u-w etc/cdver etc/cdcust etc/tcq_convert etc/cfg_convert;
	fi

	echo ... Done.

	#=============
	# Verify files exist
	#=============
	echo
	echo "Verify $PRODUCT_FULL_NAME for UNIX $client_or_server files are extracted."
	echo
	FILE_MISSING=0

	for file in $norm_filelist; do
		if [ ! -f $file -a ! -d $file ]; then
			echo
			echo "File $file is missing!"
			FILE_MISSING=1
		fi
	done

	if [ $FILE_MISSING -eq 1 ]; then
		echo
		echo "Installation aborted. Contact Support immediately."
		echo "The Contact number is listed in the inside cover of the Administration Guide"
		exit 1
	elif [ X"$client_or_server" = X"server" ] ||
	     [ X"$client_or_server" = X"server_and_cliapi" ]; then
	    # We'll check this later if the user exits a server "upgrade", and did not
	    # update Secure+ too.  The product won't start if they don't update Secure+ too.
        SPVERIFY__SERVER_HAS_BEEN_UNPACKED=true
        SPVERIFY__SECP_HAS_BEEN_UNPACKED=false
	fi
	echo ... Done.
}		# end of extract_n_verify

#===========
# Install server files
#===========
install_server() # function start
{

	#  echo
	#  echo Install $PRODUCT_FULL_NAME for UNIX Server $PROD_VERSION for the user ...
	#  echo

	if [ "$Install_option" != "UPGRADE" ]
	then
		#=============
		# Selecting the destination directory
		#=============
		val_free_disk=1
		while [ $val_free_disk -eq 1 ]
		do
			cd $DESTINATION_PATH

			#===========
			# check enough disk space is available
			#===========
			chk_free_disk "$DESTINATION_PATH" "$SVCDISKREQ" "server"
			val_free_disk=$?
		done
	fi

	cd $DESTINATION_PATH

	#=============
	# Extracting server files
	#=============
	extract_n_verify server
	cd ..

	# Check for SNA
	solaris_sna_select

	echo
	echo "$PRODUCT_FULL_NAME for UNIX Version ${PROD_VERSION} installed."

}	# end of install_server

#============
# Install CLI/API
#============
install_cliapi()	# start of install_cliapi
{
	DESTINATION_PATH=$1
	Device=$2
	Hostname=$3

	#  echo
	#  echo Install $PRODUCT_FULL_NAME for UNIX CLI/API $PROD_VERSION for user ...
	#  echo

	if [ "$Install_option" != "UPGRADE" ]
	then
		#=============
		# Selecting the destination directory
		#=============
		val_free_disk=1
		while [ $val_free_disk -eq 1 ]
		do
			cd $DESTINATION_PATH

			#===========
			# check enough disk space is available
			#===========
			chk_free_disk  "$DESTINATION_PATH" "$CLIDISKREQ" "client"
			val_free_disk=$?
		done
	fi

	cd $DESTINATION_PATH

	#=============
	# Extracting CLI/API files
	#=============
	extract_n_verify client
	cd ..

	#===========
	# Build two shell scripts for awk program
        #===========
	STATAWK_FILE=$DESTINATION_PATH/ndm/bin/ndmstat
	PROCAWK_FILE=$DESTINATION_PATH/ndm/bin/ndmproc
        VIEWPROCAWK_FILE=$DESTINATION_PATH/ndm/bin/ndmview

        echo "$NAWK -f $DESTINATION_PATH/ndm/bin/ndmproc.awk" > $PROCAWK_FILE
        echo "$NAWK -f $DESTINATION_PATH/ndm/bin/ndmstat.awk" > $STATAWK_FILE
        echo "$NAWK -f $DESTINATION_PATH/ndm/bin/ndmview.awk" > $VIEWPROCAWK_FILE

	if [ -f $PROCAWK_FILE ]; then
		chmod 755 $PROCAWK_FILE
	fi

	if [ -f $STATAWK_FILE ]; then
		chmod 755 $STATAWK_FILE
	fi

        if [ -r $VIEWPROCAWK_FILE ]; then
                chmod 755 $VIEWPROCAWK_FILE
        fi

	echo
	echo "$PRODUCT_FULL_NAME for UNIX Version ${PROD_VERSION} installed."
	
}	# end of install_cliapi


# 4.2.0.0 ILMT Installation tag file must be added if server installed.
func_create_ILMT_file ()
{
    # Add $DESTINATION_PATH/properties/version/<product_name>.swtag  file if
    # it does not already exist.

    EXIT_STATUS=0
    PROD_ILMT_FILE="IBM_Sterling_Connect_Direct_for_UNIX-${INSTALLING_VER}.${INSTALLING_REL}.${INSTALLING_MOD}.swtag"

    chmod u+w $DESTINATION_PATH/etc/swtag.txt

    if [ X"$Install_option" = X"SVR_CLI"  ]  ||
       [ X"$Install_option" = X"SVR_ONLY" ]; then
        if mkdir -p $DESTINATION_PATH/properties/version/; then
            if [ ! -f $DESTINATION_PATH/properties/version/$PROD_ILMT_FILE ]; then
                if touch $DESTINATION_PATH/properties/version/$PROD_ILMT_FILE; then
                    chmod u+rw $DESTINATION_PATH/properties/version/$PROD_ILMT_FILE
                    mv $DESTINATION_PATH/etc/swtag.txt $DESTINATION_PATH/properties/version/$PROD_ILMT_FILE
                else
                    EXIT_STATUS=1
                fi
            fi
        else
            EXIT_STATUS=1
        fi
    else
        # The properties tag file is ONLY to be installed with the server product.
        rm $DESTINATION_PATH/etc/swtag.txt
    fi

    if [ $EXIT_STATUS -ne 0 ]; then
        # The above commands will have printed the specific problem to stdout/stderr
        printf '\nUnable to create ILMT Installation file:\n  %s\n' "$DESTINATION_PATH/$PROD_ILMT_FILE"
    fi

    return $EXIT_STATUS
}

#============
# get installed file agent build date
#============
get_Installed_FA_build_date() # function start
{
	if [ -n "$FA_Version_str" ]
	then
		Installed_FA_build_date="`echo $FA_Version_str | $NAWK ' match($0,/[Dd]ate/) { print substr($0, RSTART ) } ' | awk ' { print $2 } ' | sed 's/\///g'`"
	else
		echo
		echo "cdinstall error: invalid Installed_FA_build_date"
		echo
		Installed_FA_build_date="99999999"
	fi
}

#============
# Install File Agent
#============
install_file_agent() # function start
{
	# Give the parameters meaningful names
	DESTINATION_PATH=$1
	Device=$2
	Hostname=$3

	#=============
	# Selecting the destination directory
	#=============
	val_free_disk=1
	while [ $val_free_disk -eq 1 ]
	do
		cd $DESTINATION_PATH

		AGENT_DIR=${DESTINATION_PATH}/file_agent

		#===========
		# check enough disk space is available
		#===========
		if [  \( -f $AGENT_DIR/fasat.jar \)  -o  \( "$Install_option" = "UPGRADE" \)  ]; then
			# If the File Agent is already installed or the File Agent is not installed and we are upgrading,
			# there is no need to check disk space.
			val_free_disk=0
		else
			chk_free_disk  "$DESTINATION_PATH" "$FADISKREQ" "file_agent"
			val_free_disk=$?
		fi
	done
	cd $DESTINATION_PATH

	# If the File Agent is not already installed and we are performing an upgrade, there is nothing to do.
	if [  \( "$Install_option" = "UPGRADE" \)  ]; then
		Do_FA_Upgrade=0							# SR1356970
                if [ -f $AGENT_DIR/fasat.jar ]
		then
			echo "Checking File Agent Option version"		# SR1356970 begin
			cd $AGENT_DIR
			FA_Version_str="`./cdfa -p1 2>/dev/null | grep -i Date`"
			if [ -n "$FA_Version_str" ]
			then
				get_Installed_FA_build_date
				if [ $Installed_FA_build_date -le $NUFA_build_date ]
				then
					Do_FA_Upgrade=1
				fi
			else
				Do_FA_Upgrade=1
			fi
			cd $DESTINATION_PATH
		fi
		if [ $Do_FA_Upgrade -eq 0 ]
		then
			return 0
		else
			echo "File Agent Option will be upgraded"
		fi								# SR1356970 end
	fi

	#=============
	# Extracting files
	#=============
	extract_n_verify "file_agent"

	# Work in the File Agent directory
	cd $AGENT_DIR

	# Determine whever the File Agent for this platform has a bundled JRE.
	bundledJRE=false
	if [ "$SYSTEM_NAME" = "SunOS" ]; then
		bundledJRE=true
	elif [ "$SYSTEM_NAME" = "Linux" ]; then
		hwName=`uname -m`
		if [ ! "$hwName" = "s390" ]; then
			if [ ! "$hwName" = "s390x" ]; then
				bundledJRE=true
			fi
		fi
	elif [ "$SYSTEM_NAME" = "AIX" ]; then
		bundledJRE=true
	elif [ "$SYSTEM_NAME" = "HP-UX" ]; then
		bundledJRE=true
	else
		bundledJRE=false
	fi

        # Start building a properties file for the install
        rm -f installer.properties
        echo "USER_INSTALL_DIR=${AGENT_DIR}" >  ./installer.properties
        echo "USER_INSTALL_DIR_SET=YES"   >> ./installer.properties
        echo "INSTALLER_UI=CONSOLE"          >> ./installer.properties

	# If the File Agent has a bundled JRE, we perform an overwrite installation for both a fresh install
	# and an upgrade. If the File Agent does not have a bundled JRE, we perform a fresh install unless
	# this is an upgrade installation, in which case we re-use the JRE.
	if [  \( "$bundledJRE" = "false" \)  ]
	then
		if [  \( "$Install_option" = "UPGRADE" \)  ]
		then
			# Extract the path to the JRE from cdfa.sh. The jre path may be wrapped in double quotes.
			if [ -f $AGENT_DIR/cdfa.sh ]
			then
				jre=`grep java $AGENT_DIR/cdfa.sh | cut -d" " -f1`
			else
				jre=`grep java $AGENT_DIR/cdfa | cut -d" " -f1`
			fi
			jre=`echo $jre | tr -d \"`
			jre_version=`$jre -version 2>&1 | grep version | cut -d' ' -f3 | cut -d'"' -f2`
			java_version=`echo $jre_version | cut -d. -f1`
			java_release=`echo $jre_version | cut -d. -f2`
			usable_jre=1
			if [ $java_version -lt 1 ]
			then
				usable_jre=0
			elif [ $java_version -gt 1 ]
			then
				usable_jre=1
			elif [ $java_release -lt 6 ]
			then
				usable_jre=0
			fi
			if [ $usable_jre -eq 1 -o "$SYSTEM_NAME" = "OSF1" ]
			then
				# Specify the JRE in the properties file
				echo "MY_JAVA_EXECUTABLE=${jre}"   >> ./installer.properties
			else
				echo
				echo "WARNING:  JRE version referenced by the installed File Agent is too old.  Current File Agent "
				echo "          requires JRE 1.6 or greater.  The JRE version referenced by the installed File "
				echo "          Agent is in the following directory: "
				echo
				echo "$jre"
				echo
				echo "          and is version $jre_version.  During the following File Agent installation "
				echo "          procedure you will be asked to specify a JRE to use.  Be sure to specify a JRE of "
				echo "          1.6 or greater. "
				echo
				echo 'Press ENTER when ready.'
                                echo "### File Agent JRE is too old."
				read null
				if [ "$cdai_installCmd" != "" ]; then
                               	 echo_nn " $null"
	                        fi
			fi
		elif [ "$SYSTEM_NAME" != "OSF1" ]
		then
			echo
			echo "CAUTION:  Current File Agent requires JRE 1.6 or greater.  During the following File Agent "
			echo "          installation procedure you will be asked to specify a JRE to use.  Be sure to "
			echo "          specify a JRE of 1.6 or greater. "
			echo
			echo "NOTICE:  The current version of the File Agent Installer has a known issue which may result "
			echo "         in the following message being displayed: "
			echo
			echo "            Unable to install the Java Virtual Machine included with this installer. "
			echo
			echo "         Please ignore this message. "
			echo
			echo 'Press ENTER when ready.'
			read null
			if [ "$cdai_installCmd" != "" ]; then
       				echo_nn " $null"
                       fi
		fi
	fi

	# defect 492 start of change
	if [ "$SYSTEM_NAME" = "Linux" ]
	then
		# check if the export LD_ASSUME_KERNEL breaks shell commands. If it does, (on SuSE ES 10)
		# then we have to 'fix' the InstallAnywhere binary for FA 
		lsak=$LD_ASSUME_KERNEL
		export LD_ASSUME_KERNEL=2.2.5
		lsout=`ls 1> /dev/null 2> /dev/null`
		lscode=$?
		export LD_ASSUME_KERNEL=$lsak
		if [ $lscode != 0 ]
		then
			cp install.bin install.bak
			cat install.bak | sed "s/export LD_ASSUME_KERNEL/#xport LD_ASSUME_KERNEL/" > install.bin
		fi
	fi
	# defect 492 end of change

	if [ \( "$Install_option" = "UPGRADE" \) -a \( "$bundledJRE" = "true" \) ]
	then
		rm -rf $AGENT_DIR/jre
	fi

	# Run the File Agent install
	chmod u+x ./install.bin
	./install.bin
	# RTC 315406 - remove installer after installation. It is a big file taking up space for
	#              no good reason.
	rm ./install.b??

	FA_Version_str="`./cdfa -p1 2>/dev/null | grep -i Date`"
	if [ -n "$FA_Version_str" ]
	then
		get_Installed_FA_build_date
		if [ $Installed_FA_build_date -ne $NUFA_build_date ]
		then
			echo
			echo "cdinstall error: Installed_FA_build_date and NUFA_build_date do not agree after File Agent install."
			echo
			exit 1
		fi
	else
		echo
		echo "cdinstall error: cdfa -p command failed"
		echo
		exit 1
	fi

	cd $DESTINATION_PATH

	if [  \( "$Install_option" = "UPGRADE" \)  ]; then
		echo
		echo "File Agent upgrade completed"
		echo
		sleep 2
	fi
}       # end of install_file_agent

#===========
# Install both server and CLI/API files
#===========
install_server_and_cliapi()	# start of install_server_and_cliapi
{
	#  echo
	#  echo Install both $PRODUCT_FULL_NAME for UNIX Server $PROD_VERSION and
	#  echo Client(CLI/API) $PROD_VERSION for the user ...
	#  echo

	if [ "$Install_option" != "UPGRADE" ]
	then
		#=============
		# Selecting the destination directory
		#=============
		val_free_disk=1
		while [ $val_free_disk -eq 1 ]
		do
			cd $DESTINATION_PATH

			#===========
			# check enough disk space is available
			#===========
			chk_free_disk  "$DESTINATION_PATH"  "$TOTAL_DISKREQ" "server"
			val_free_disk=$?
		done
	fi

	cd $DESTINATION_PATH

	#=============
	# Extracting files
	#=============
	extract_n_verify "server_and_cliapi"
	cd ..

	#===========
	# Build two shell scripts for awk program
        #===========
	STATAWK_FILE=$DESTINATION_PATH/ndm/bin/ndmstat
	PROCAWK_FILE=$DESTINATION_PATH/ndm/bin/ndmproc
        VIEWPROCAWK_FILE=$DESTINATION_PATH/ndm/bin/ndmview

        echo "$NAWK -f $DESTINATION_PATH/ndm/bin/ndmproc.awk" > $PROCAWK_FILE
        echo "$NAWK -f $DESTINATION_PATH/ndm/bin/ndmstat.awk" > $STATAWK_FILE
        echo "$NAWK -f $DESTINATION_PATH/ndm/bin/ndmview.awk" > $VIEWPROCAWK_FILE

	if [ -r $PROCAWK_FILE ]; then
		chmod 755 $PROCAWK_FILE
	fi

	if [ -r $STATAWK_FILE ]; then
		chmod 755 $STATAWK_FILE
	fi

        if [ -r $VIEWPROCAWK_FILE ]; then
                chmod 755 $VIEWPROCAWK_FILE
        fi
	# Check for SNA
	solaris_sna_select

}	# end of install_server_and_cliapi


#===========
# Get listfiles from CD or Tape
#===========
get_listfiles() # function start
{
	# Initialize list files
	LISTFILES=
	CLIFILES=
	SVCFILES=
	FAFILES=
	TTLFILES=

	case "$1" in
		client)
			LISTFILES="etc/cliflst1.0";;
		server)
			LISTFILES="etc/svcflst1.0";;
		file_agent)
			LISTFILES="etc/faflst1.0";;
		*)
			LISTFILES="etc/ttlflst1.0";;
	esac

	if [ -f etc/cliflst1.0 ]; then
		chmod a+wr etc/cliflst1.0
	fi
	if [ -f etc/svcflst1.0 ]; then
		chmod a+wr etc/svcflst1.0
	fi
	if [ -f etc/faflst1.0 ]; then
		chmod a+wr etc/faflst1.0
	fi
	if [ -f etc/ttlflst1.0 ]; then
		chmod a+wr etc/ttlflst1.0
	fi

	echo
	echo "... Extracting $1 installation listfile from the media."
	if [ -z "$Hostname" ]; then    # extract diskfree utility
		case "`uname -s`" in	
			Linux)
				cpio -idmVu $LISTFILES < $Device;;
			*)
				cpio -cidmuB $LISTFILES < $Device;;
		esac
	else
		case "`uname -s`" in	
			Linux)
				$RSHELL $Hostname -n "dd if=$Device ibs=5120" | cpio -idmVu $LISTFILES;;
			*)
				$RSHELL $Hostname -n "dd if=$Device ibs=5120" | cpio -cidmuB $LISTFILES;;
		esac
	fi

	#==========
	# Set list files
	#==========
	case "$1" in
		client)
			CLIFILES="`cat etc/cliflst1.0 | tr '\012' '\040' `";;
		server)
			SVCFILES="`cat etc/svcflst1.0 | tr '\012' '\040' `";;
		file_agent)
			FAFILES="`cat etc/faflst1.0 | tr '\012' '\040' `";;
		*)
			TTLFILES="`cat etc/ttlflst1.0 | tr '\012' '\040' `";;
	esac

}

#=========
# Set the media
#=========
set_device() # function start
{
        # Find current OS, vendor and arch to give customer an example
        # CDROM directory path.  If we can't get these then just give
        # an example path using the IBM directory.  It's success is not
        # critical.

        THIS_ARCH=`uname -m 2> /dev/null`
        THIS_OS=`uname 2> /dev/null`
        CDROM_DIR="IBM"  # If arch not found then this used as default example.
                         # We don't search for AIX below.  It is "IBM" already.

        if   [ "X${THIS_OS}" = 'XHP-UX' ]
           then if   [ `echo ${THIS_ARCH} | grep -c '9000'` -eq 1 ]
                   then CDROM_DIR='HP_PA-RISC'
                elif [ `echo ${THIS_ARCH} | grep -c 'ia64'` -eq 1 ]
                   then CDROM_DIR='HP_Itanium'
                fi
        elif [ "X${THIS_OS}" = "XLinux" ]
           then if   [ `echo ${THIS_ARCH} | grep -c 'i.86'`   -eq 1 -o \
                       `echo ${THIS_ARCH} | grep -c 'x86_64'` -eq 1 ]
                   then if   [ -f /etc/redhat-release ]
                           then CDROM_DIR='RedHat_linux'
                        elif [ -f /etc/SuSE-release ]
                           then CDROM_DIR='SuSE_linux'
                        fi
                elif [ `echo ${THIS_ARCH} | grep -c 's390'` -eq 1 ]
                   then CDROM_DIR='IBMS390_linux'
                elif [ `echo ${THIS_ARCH} | grep -c 's390x'` -eq 1 ]
                   then CDROM_DIR='IBMS390_linux'
                fi
        elif [ "X${THIS_OS}" = "XSunOS" ]
           then if   [ `echo ${THIS_ARCH} | grep -c 'sun'`  -eq 1 ]
                   then CDROM_DIR='Sun_Solaris'
                elif [ `echo ${THIS_ARCH} | grep -c 'i86pc'` -eq 1 ]
                   then CDROM_DIR='Solaris_x86'
                fi
        elif [ "X${THIS_OS}" = "XOSF1" ]
           then CDROM_DIR='HP_Tru64'
        fi


    while [ true ]; do
        echo
        Device=""
        Invalue=""

        while [ -z "$Invalue" ]; do
            echo "Specify the fully qualified name of the $PRODUCT_FULL_NAME for UNIX installation"
            echo "file (file name prefixed with the absolute path, e.g., /localhome/cdadmin/$DESTINATION): "
            read Invalue

            if [ -n "$cdai_installCmd" ]; then
                if [ -z "$Invalue" ]; then
                    echo "\n### cpio file path/name not entered. input=$YESNO"
                    exit 108
                fi
            fi
        done

        # "read" will not expand var names, if the user gave us any.
        eval "Device=$Invalue"

        #===============
        # Test device
        #===============
        if [ -r "$Device" ]; then
            printf '\nValidating CPIO installation file...\n'

            # CPIO command line arguments for only retrieving the table of contents.
            CPIO_TOC_ARGS=""
            if [ X"$SYSTEM_NAME" = X"Linux" ]; then
                CPIO_TOC_ARGS="it"
            else
                CPIO_TOC_ARGS="cit"
            fi

            # This logic updated for 4.2.  We used to check that the cpio file
            # contained a file called "cdpmgr".  If it didn't then it was a
            # bad cpio file.  With 4.2 we enhance this step.  Instead of the
            # cdpmgr, we look for the embedded secure+ cpio file.  If we don't
            # get that then it's still a bad cpio file.  Additionally, if it
            # doesn't match the *_sp_ssl name for "this" arch, that's bad too.
            # This will assist the user if they've downloaded the wrong cpio.

            EMBEDDED_SECP_CPIO=`cpio -$CPIO_TOC_ARGS *_sp_ssl < $Device 2>&1 | grep _sp_ssl`
            if [ $? -ne 0 ]; then
                echo
                echo "${Device} is not a $PRODUCT_FULL_NAME for UNIX cpio installation file."
                if [ -n "$cdai_installCmd" ]; then
                    exit 110
                else
                    continue
                fi
            fi

            IS_CPIO_MISMATCH=true
            case "$SYSTEM_NAME" in
                AIX   )            if [ X"$EMBEDDED_SECP_CPIO" = X"aix_sp_ssl" ];         then IS_CPIO_MISMATCH=false; fi ;;
                Linux )
                    case "$ARCH_NAME" in
                        x86*|i686) if [ X"$EMBEDDED_SECP_CPIO" = X"linux_sp_ssl" ];       then IS_CPIO_MISMATCH=false; fi ;;
                        s390*    ) if [ X"$EMBEDDED_SECP_CPIO" = X"linuxmfrm_sp_ssl" ];   then IS_CPIO_MISMATCH=false; fi ;;
                    esac ;;
                HP-UX )
                    case "$ARCH_NAME" in
                        9000/800 ) if [ X"$EMBEDDED_SECP_CPIO" = X"hpux_sp_ssl" ];        then IS_CPIO_MISMATCH=false; fi ;;
                        ia64     ) if [ X"$EMBEDDED_SECP_CPIO" = X"hpuxit_sp_ssl" ];      then IS_CPIO_MISMATCH=false; fi ;;
                    esac ;;
                SunOS )
                    case "$ARCH_NAME" in
                        sparc    ) if [ X"$EMBEDDED_SECP_CPIO" = X"solaris_sp_ssl" ];     then IS_CPIO_MISMATCH=false; fi ;;
                        i386     ) if [ X"$EMBEDDED_SECP_CPIO" = X"solaris_x86_sp_ssl" ]; then IS_CPIO_MISMATCH=false; fi ;;
                    esac ;;
            esac

            if $IS_CPIO_MISMATCH; then
                printf '\nThe CPIO archive file provided is for a different platform.\n'
                printf 'This platform is %s on %s.\n' "$SYSTEM_NAME" "$ARCH_NAME"

                MATCHING_ARCH=""
                case $EMBEDDED_SECP_CPIO in
                    aix_sp_ssl         ) MATCHING_ARCH="AIX on POWERPC";;
                    linux_sp_ssl       ) MATCHING_ARCH="Linux on x86/x86_64";;
                    linuxmfrm_sp_ssl   ) MATCHING_ARCH="Linux on s390 mainframe";;
                    hpux_sp_ssl        ) MATCHING_ARCH="HP-UX on PA-RISC";;
                    hpuxit_sp_ssl      ) MATCHING_ARCH="HP-UX on Itanium";;
                    solaris_sp_ssl     ) MATCHING_ARCH="Solaris on SPARC";;
                    solaris_x86_sp_ssl ) MATCHING_ARCH="Solaris on x86/x86_64";;
                    *                  ) MATCHING_ARCH="an unknown architecture.";;
                esac

                printf '\nThe file: %s\nis the CPIO installation file for %s\n' "$Device" "$MATCHING_ARCH"
                if [ -n "$cdai_installCmd" ]; then
                    exit 111
                else
                    continue
                fi
            else
                # Is good cpio, and matches this arch.
                break # The while()
            fi
        else
            echo
            echo "$Device: File does not exist or is not readable."
            if [ -n "$cdai_installCmd" ]; then
                exit 109
            else
                continue
            fi
        fi
    done
}

#===================================================================#
#
# 3.8 get secure+ install script and invoke it to install secure+
#
#===================================================================#
invoke_secure_plus()
{
    RC_invoke_secure_plus=0

	Cpio=
	case $SYSTEM_NAME in
		Linux)
			if [ `uname -m` = "s390" -o `uname -m` = "s390x" ]; then
				Cpio=linuxmfrm_sp_ssl
			else
				Cpio=linux_sp_ssl
			fi
			;;
		HP-UX)
                        if [ `uname -m` = "ia64" ]
                          then
                            Cpio=hpuxit_sp_ssl
                          else
                            Cpio=hpux_sp_ssl
                        fi
			;;
		AIX)
			Cpio=aix_sp_ssl
			;;
		SunOS)
                        if [ `uname -m` = "i86pc" ]
                          then
                            Cpio=solaris_x86_sp_ssl
                          else
                            Cpio=solaris_sp_ssl
                        fi
                        ;;
		OSF1)
			Cpio=cpqtru64_sp_ssl
			;;
	esac

	if [ -n "$SECURE_UPGRADE" ]; then
		echo
		echo "Secure Plus Option installation detected."
		echo
	else
		echo
		echo "$PRODUCT_FULL_NAME Secure+ Option for UNIX $PROD_VERSION will be"
		echo_nn "installed on your system. Do you want to continue?:[Y/n]"
		yes_or_no
	fi

	val_free_disk=1
	while [ $val_free_disk -eq 1 ]
	do
		cd $DESTINATION_PATH

		#===========
		# check enough disk space is available
		#===========
		chk_free_disk "$DESTINATION_PATH" "$SPINSTALLDISKREQ" "s+install"
		val_free_disk=$?
	done

	if [ "$YESNO" = "y" -o -n "$SECURE_UPGRADE" ]; then

		if [ -d ./ndm ]; then
			NDM_NOTEXISTED=
		else
			NDM_NOTEXISTED=1
		fi

		if [ "X$Device" != "X" ]; then
			echo "Extracting $PRODUCT_FULL_NAME Secure+ Option for UNIX Install Script and cpio file ...."
			cd "$DESTINATION_PATH"
			case "$SYSTEM_NAME" in
				Linux)
					cpio -idmVu "secure+_inst" < $Device 2>/dev/null
					cpio -idmVu "$Cpio" < $Device 2>/dev/null
					;;
				*)
					cpio -cidmuB "secure+_inst" < $Device 2>/dev/null
					cpio -cidmuB "$Cpio" < $Device 2>/dev/null
					;;
			esac
			cd "$CDINST_DIR"
		else
			echo "Extract $PRODUCT_FULL_NAME Secure+ Option for UNIX Install Script and cpio file ...."
			break
		fi
		if [ -f ${DESTINATION_PATH}/secure+_inst ]; then
			CPIO_FILE="$DESTINATION_PATH/$Cpio"
			if [ -n "$SECURE_UPGRADE" ]; then
				sleep 2;sh "$DESTINATION_PATH/"secure+_inst "$DESTINATION_PATH" "$CPIO_FILE" "$Hostname" "1"
                if [ $? -eq 0 ]; then
				    echo "Secure Plus Option upgrade succeeded."
                else
				    echo "Secure Plus Option upgrade FAILED!"
                    RC_invoke_secure_plus=3
                fi
                SPVERIFY__SECP_HAS_BEEN_UNPACKED=true
				sleep 2
			else
				sleep 2;sh "$DESTINATION_PATH/"secure+_inst "$DESTINATION_PATH" "$CPIO_FILE" "$Hostname"
                SPVERIFY__SECP_HAS_BEEN_UNPACKED=true
			fi
			rm -f ${DESTINATION_PATH}/secure+_inst
			rm -f "$CPIO_FILE"
			if [ -d ./ndm ]; then
				if [ -n "$NDM_NOTEXISTED" ]; then
					rm -rf ./ndm
				fi
			fi
		else
			echo "Extract $PRODUCT_FULL_NAME Secure+ Option for UNIX Install Script, secure+_inst, and cpio file $Cpio and reissue"
			echo cdinstall.
		fi
	else
		if [ -z "$SECURE_FEATURES" ]; then
			echo
			MAIN_MENU=1
		fi
	fi


    return $RC_invoke_secure_plus
}	# end invoke_secure_plus()

#===================================================================#
#
#          Installation Procedure
#
#===================================================================#
#

EXIT_STATUS=0

#===============
# Determine how to echo without new line added
#===============
echoes=`echo -n`
if [ "$echoes" = "-n" ]; then
	V_echo=TRUE	# System V version of echo
else
	V_echo=FALSE
fi

#===============
# Display Warning for root install
#===============
INSTID=`id|grep 'uid=0'`
if [ "X$INSTID" != "X" ]; then
	echo
	echo 'WARNING: WARNING: WARNING: WARNING: WARNING: WARNING:'
	echo
	echo "You are about to install $PRODUCT_FULL_NAME for UNIX as root."
	echo 'You may want to create another account for this installation.'
	echo
	echo 'After installing as root, you can risk: "deleting or overwriting'
	echo 'system files, security, etc, etc."'
	echo
	echo_nn "Do you want to continue with this installation?:[Y/n]:";yes_or_no
	if [ "$YESNO" = "n" ]; then
		exit 1
	fi
fi

#===============
# Display warning for umask restriction (SR1353111)
#===============
UMASKOUT=`umask | awk ' { printf("%d", int($1)) } '`
if [ $UMASKOUT -ne 0 -a $UMASKOUT -ne 2 -a $UMASKOUT -ne 22 ]
then
	$CLEAR
	echo
    if [ X"$PRODUCT_FULL_NAME" = X"Connect:Direct" ]; then
	    echo 'IBM(R) Sterling Connect:Direct(R) for UNIX pre-installation check - CAUTION:'
    else
	    echo "$PRODUCT_FULL_NAME for UNIX pre-installation check - CAUTION:"
    fi
	echo
	echo "The current umask setting of the install shell, $UMASKOUT, may"
	echo 'be too restrictive.  If the installation procedure continues with'
	echo 'this umask setting, some users may not have the necessary'
	echo "permissions to use $PRODUCT_FULL_NAME for UNIX.  If it does not violate"
	echo 'your security policies, a umask setting of 22 is recommended.'
	echo
	echo_nn "Do you want to change the umask setting to 22 before proceeding?:[Y/n]:";yes_or_no
	if [ "$YESNO" = "y" ]; then
		umask 22
	fi
fi

CDINST_DIR=`pwd|sed s/'\/tmp_mnt'//`
$CLEAR
sleep 1
echo
echo
echo '================================================================'
if [ X"$PRODUCT_FULL_NAME" = X"Connect:Direct" ]; then
    echo 'Licensed Materials - Property of IBM'
    echo
    echo 'IBM(R) Sterling Connect:Direct(R) for UNIX'
    echo
    echo '(C) Copyright IBM Corp. 1992, 2016 All Rights Reserved.'
    echo
    echo 'US Government Users Restricted Rights - Use, duplication or disclosure'
    echo 'restricted by GSA ADP Schedule Contract with IBM Corp.'
else
    echo "$PRODUCT_FULL_NAME for UNIX"
fi
echo
echo "You are beginning the $PRODUCT_FULL_NAME for UNIX Installation"
echo "Procedure.  You will be asked to specify a directory (called"
echo "the destination directory) where the $PRODUCT_FULL_NAME for UNIX"
echo 'files will be stored.'
echo
echo 'Please follow the Getting Started Guide and/or Release Notes for the'
echo 'proper Media Name.'
echo
echo 'UNIX is a registered trademark of The Open Group'
echo ================================================================
echo
echo 'Press ENTER when ready.'
read null
if [ "$cdai_installCmd" != "" ]; then
  echo_nn " $null"
fi



#===============
# QA Defect #416.
# Check for AIX C++ runtime libraries.  C:D 4.0.00 will not run if these
# are not installed AND are not at 5.0.rte.8 or greater.
#===============
#
if [ "X${SYSTEM_NAME}" = "XAIX" ]
  then
    echo "Verify appropriate version of C Set ++ Runtime for AIX...                \c"
    RET_CODE=1
    lslpp -Lc | egrep "xlC\.aix[56].\.rte:[891]" > /dev/null 2>&1
    RET_CODE=$?

    if [ $RET_CODE -eq 0 ]
      then
        echo '[Yes]'
    else
        echo '[No]'
        $CLEAR
        echo
        echo '======================================================================='
        echo 'WARNING: Unable to locate IBM C Set ++ Runtime libraries for AIX at'
        echo 'version 5.0.rte.8 or greater.'
        echo "$PRODUCT_FULL_NAME 4.2.0.0 will not run without these C++ runtime libraries."
        echo
        echo 'These libraries are available for free at the following website:'
        echo 'http://www-1.ibm.com/support/docview.wss?uid=swg24011532'
        echo
        echo "Please see the $PRODUCT_FULL_NAME 4.2.0.0 Release Notes for more information."
        echo 'After the libraries are installed, re-run the installation program.'
        echo 'Thank you.'
        echo '======================================================================='
        echo
        echo 'Exiting installation program.'
        echo
        exit 1
    fi
fi

#===============
# QA Defect #11270
# Check for AIX pthreads Library.  C:D 4.0.00 will not run if these
# are not installed AND are not at 5.3.7.0 or greater on AIX 5.3.
# AIX 6.1 and higher are fine.
#===============
#
if [ "X${SYSTEM_NAME}" = "XAIX" ]
  then
    echo "Verify appropriate version of pthreads Library for AIX...                \c"
    GOOD_PTHREADS=0
    PTHREADS_VERSION=`lslpp -Lc | egrep "rte.libpthreads" | cut -d: -f3 | cut -d. -f1`
    PTHREADS_RELEASE=`lslpp -Lc | egrep "rte.libpthreads" | cut -d: -f3 | cut -d. -f2`
    PTHREADS_SERVICEPACK=`lslpp -Lc | egrep "rte.libpthreads" | cut -d: -f3 | cut -d. -f3`
    if [ $PTHREADS_VERSION -ge 6 ]
    then
        GOOD_PTHREADS=1
    elif [ $PTHREADS_VERSION -eq 5 -a $PTHREADS_RELEASE -eq 3 -a $PTHREADS_SERVICEPACK -ge 7 ]
    then
        GOOD_PTHREADS=1
    fi

    if [ $GOOD_PTHREADS -eq 1 ];then
        echo '[Yes]'
    else
        echo '[No]'
        $CLEAR
        echo
        echo '======================================================================='
        echo 'WARNING: Unable to locate IBM pthreads Library for AIX at'
        echo 'version 5.3.7.0 or greater.'
        echo "$PRODUCT_FULL_NAME 4.2.0.0 will not run without this library."
        echo
        echo 'This library is available for free at the following website:'
        echo 'http://www-1.ibm.com/support/docview.wss?uid=isg1fileset2053285771'
        echo 'Alternatively, you can install a current AIX Service Pack.'
        echo
        echo "Please see the $PRODUCT_FULL_NAME 4.2.0.0 Release Notes for more information."
        echo 'After the library is installed, re-run the installation program.'
        echo 'Thank you.'
        echo '======================================================================='
        echo
        echo 'Exiting installation program.'
        echo
        exit 1
    fi
fi


#===============
# Check for Linux C++ runtime libraries.  C:D 4.2.0.0 will not run if the correct
# version is not installed.  We're looking for the current version in the test here.
#===============
#
if [ "X${SYSTEM_NAME}" = "XLinux" ];then
    echo -n "Verify standard C++ libraries are installed...    "
    /bin/ls /usr/lib/libstdc++.so.6* > /dev/null 2>&1
    RET_CODE=$?

    # 4.2.0.0  Removed ldconfig check because ldconfig will not differentiate
    # between 32bit and 64bit libs. So we got false "already installed" positives.
    # The 64bit libs are in /usr/lib64/ so, we just look in /usr/lib/

    if [ $RET_CODE -eq 0 ];then
        echo '[Yes]'
    else
        echo '[No]'
#        $CLEAR
        echo
        echo '======================================================================='
        echo 'WARNING: Unable to locate the standard C++ runtime libraries on this system.'
        echo "$PRODUCT_FULL_NAME 4.2.0.0 will not run without these C++ runtime libraries."
        echo
        echo 'These libraries come with the distribution media for this operating'
        if [ X"$ARCH_NAME" = X"s390"  ] ||
           [ X"$ARCH_NAME" = X"s390x" ]; then
            echo 'system.  Please ask your System Administrator to install the 31bit'
            echo 'package named:  libstdc++.s390'
        else
            echo 'system.  Please ask your System Administrator to install the 32bit'
            echo 'package named:  libstdc++.i386   -or-'
            echo 'package named:  libstdc++.i586   -or-'
            echo 'package named:  libstdc++.i686'
            echo 'Depending on the age of your Linux system, only one of those will be available.'
        fi
        echo
        echo "Please see the $PRODUCT_FULL_NAME 4.2.0.0 Release Notes for more information."
        echo 'After the libraries are installed, re-run the installation program.'
        echo 'Thank you.'
        echo '======================================================================='
        echo
        echo 'Exiting installation program.'
        echo
        exit 1
    fi
fi


#===============
# For 4.2.0.0, check that Solaris is at 5.10 U10 (Aug 2011) or greater.
# Both SPARC and x86.
#===============
if [ X"$SYSTEM_NAME" = X"SunOS" ]; then
    printf 'Verify version of runtime libraries for Solaris...                     '

    HAS_CURRENT_SOL_LIBS=false
    SOL_VERSION=`uname -r | sed 's/5\.//'`

    if [ -n "$SOL_VERSION" ]; then
        if [ $SOL_VERSION -gt 10 ]; then
            HAS_CURRENT_SOL_LIBS=true
        elif [ $SOL_VERSION -eq 10 ]; then
            if [ -s "/etc/release" ]; then
                UPDATE_LEVEL=`grep " s10[sx]_" /etc/release | sed -e 's/.*\ s10[sx]_u//' -e 's/wos_.*//'`

                if [ -n "$UPDATE_LEVEL"   ]  &&
                   [ $UPDATE_LEVEL -ge 10 ]; then
                    HAS_CURRENT_SOL_LIBS=true
                fi
            fi
        fi
    fi

    if $HAS_CURRENT_SOL_LIBS; then
        echo '[Yes]'
    else
        echo '[No]'
        echo
        echo '==========================================================================='
        echo "WARNING: $PRODUCT_FULL_NAME for Solaris requires runtime library versions that"
        echo 'come with Solaris 5.10 with Update Level 10 (Aug 2011) or greater.'
        echo "$PRODUCT_FULL_NAME 4.2.0.0 will not run with the older runtime libraries or"
        echo 'a version of Solaris that is older than 5.10, patched to Update Level 10.'
        echo 'The Solaris version and Update Level are listed in the "/etc/release" file.'
        echo
        echo "Please see the $PRODUCT_FULL_NAME 4.2.0.0 Release Notes for more information."
        echo 'After the Solaris operating system is patched or upgraded to 5.10 with'
        echo 'Update Level 10, or greater, please re-run the installation program.'
        echo 'Thank you.'
        echo '==========================================================================='
        echo
        echo 'Exiting installation program.'
        echo
        exit 1
    fi
fi


#===============
# Obtain the device name of the drive and hostname if needed
#===============
#echo_nn "Is the installation media located on the local system?:[Y/n]"; yes_or_no
#if [ "$YESNO" = "n" ]; then
#  echo
#  echo_nn "Enter hostname of the remote drive:"
#  read Hostname
#fi
# Force install media to be local
if [ -n "$Hostname" ]; then
	unset Hostname
fi

#=========
# Ask for the media
#=========
set_dest_dir
if [ "$Install_option" != "RESTORE" -a "$Install_option" != "EXIT_SCRIPT" ]
then
	set_device
fi

if [ "$Install_option" = "RESTORE" ]
then
    echo
    echo_nn "Have the $PRODUCT_FULL_NAME for UNIX Server and all installed options, such as File Agent, been stopped?:[Y/n]:";yes_or_no
    if [ "$YESNO" = "n" ]; then
	EXIT_STATUS=1
	echo
	echo "Please ensure the $PRODUCT_FULL_NAME for UNIX Server has been stopped and then rerun cdinstall."
	echo
	exit $EXIT_STATUS
    fi

    Num_of_backups=`ls -1 $DESTINATION_PATH.CDBackup.*.tar | wc -l`
    if [ $Num_of_backups -gt 1 ]
    then
	echo
	echo "Multiple backup files detected."
	echo
	echo_nn "Would you like to restore the latest backup?:[Y/n]";yes_or_no
	if [ "$YESNO" = "y" ]; then
	    for file in `ls -1 $DESTINATION_PATH.CDBackup.*.tar`
	    do
		BACKUP_FILE=$file
	    done
	else
	    while [ true ]; do
		echo
		echo "Backup files from the following dates are available:"
		echo
		for file in `ls $DESTINATION_PATH.CDBackup.*.tar`
		do
		    BACKUP_FILE_TRIM_FRONT=`echo $file | sed 's/^.*\.CDBackup\.//'`
		    BACKUP_FILE_CANDIDATE=`echo $BACKUP_FILE_TRIM_FRONT | sed 's/\.tar$//'`
		    echo $BACKUP_FILE_CANDIDATE
		done
		PROMPT='Please enter the date (YYMMDD) of the backup file you would like to restore:'
		get_value
		if [ -f "$DESTINATION_PATH.CDBackup.$VALUE.tar" ]
		then
		    BACKUP_FILE="$DESTINATION_PATH.CDBackup.$VALUE.tar"
		    break
		else
		    echo
		    echo "Invalid date entered."
		fi
	    done
	fi
    else
	BACKUP_FILE=`ls $DESTINATION_PATH.CDBackup.*.tar`
    fi

    if [ -f $BACKUP_FILE ]
    then
	echo
	echo "Backup file $BACKUP_FILE will be used."
	echo
	echo "Restore procedure may take a minute...."
	echo
	if [ "`uname -s`" = "Linux" ]
	then
	    tar xvfP $BACKUP_FILE
	    if [ -f ${DESTINATION_PATH}.CDBUncompressible ]
	    then
		cpio -tiv --absolute-filenames < ${DESTINATION_PATH}.CDBUncompressible > /dev/null 2>&1
		CPIO_STAT=$?
	    else
		(echo $DESTINATION_PATH.CDBCompressible.gz | cpio -oBv -H newc > $DESTINATION_PATH.CDBcpiotest) > /dev/null 2>&1
		cpio -tiv --absolute-filenames < ${DESTINATION_PATH}.CDBcpiotest > /dev/null 2>&1
		CPIO_STAT=$?
		rm $DESTINATION_PATH.CDBcpiotest
	    fi
	    if [ $CPIO_STAT -eq 0 ]
	    then
		ABS_FILENAMES=--absolute-filenames
	    else
		ABS_FILENAMES=
	    fi
	else
	    tar xvf $BACKUP_FILE
	fi
	if [ -f ${DESTINATION_PATH}.CDBUncompressible ]
	then
	    UNCOMPRESSIBLE_FILES=true
	else
	    UNCOMPRESSIBLE_FILES=false
	fi
	echo_nn "Would you like to restore the configuration and work files in addition to the program files?:[Y/n]";yes_or_no
	if [ "$YESNO" = "y" ]; then
	    SU_ATTEMPT=1
	    while [ true ]; do
		echo "Please wait for the prompt to appear and then enter the root password."
		if [ "$UNCOMPRESSIBLE_FILES" = "true" ]
		then
		    if [ "`uname -s`" = "Linux" ]; then
			su root -c "gunzip ${DESTINATION_PATH}.CDBCompressible; cpio -idvum $ABS_FILENAMES < ${DESTINATION_PATH}.CDBCompressible; cpio -idvum $ABS_FILENAMES < ${DESTINATION_PATH}.CDBUncompressible"
		    else
			su root -c "uncompress ${DESTINATION_PATH}.CDBCompressible; cpio -idvum < ${DESTINATION_PATH}.CDBCompressible; cpio -idvum < ${DESTINATION_PATH}.CDBUncompressible"
		    fi
		else
		    if [ "`uname -s`" = "Linux" ]; then
			su root -c "gunzip ${DESTINATION_PATH}.CDBCompressible; cpio -idvum $ABS_FILENAMES < ${DESTINATION_PATH}.CDBCompressible"
		    else
			su root -c "uncompress ${DESTINATION_PATH}.CDBCompressible; cpio -idvum < ${DESTINATION_PATH}.CDBCompressible"
		    fi
		fi
		if [ $? -eq 0 -o $SU_ATTEMPT -gt 3 ]
		then
		    break
		else
		    echo
		    echo "root command attempt $SU_ATTEMPT failed - possibly invalid password."
		    SU_ATTEMPT=`expr $SU_ATTEMPT + 1`
		fi
	    done
	    if [ $SU_ATTEMPT -gt 3 ]
	    then
		EXIT_STATUS=1
	    fi
	else
	    SU_ATTEMPT=1
	    while [ true ]; do
		echo "Please wait for the prompt to appear and then enter the root password."
		if [ "$UNCOMPRESSIBLE_FILES" = "true" ]
		then
		    if [ "`uname -s`" = "Linux" ]; then
			su root -c "gunzip ${DESTINATION_PATH}.CDBCompressible; cpio -idvumf $ABS_FILENAMES '${DESTINATION_PATH}/ndm/cfg*' '${DESTINATION_PATH}/ndm/SACL*' '${DESTINATION_PATH}/work*' '*/SwiftNet/*/cfg*' '*/SwiftNet/*/log*' '*/SwiftNet/*/process*'< ${DESTINATION_PATH}.CDBCompressible; cpio -idvumf $ABS_FILENAMES '${DESTINATION_PATH}/ndm/cfg*' '${DESTINATION_PATH}/ndm/SACL*' '${DESTINATION_PATH}/work*' '*/SwiftNet/*/cfg*' '*/SwiftNet/*/log*' '*/SwiftNet/*/process*'< ${DESTINATION_PATH}.CDBUncompressible"
		    else
			su root -c "uncompress ${DESTINATION_PATH}.CDBCompressible; cpio -idvumf '${DESTINATION_PATH}/ndm/cfg*' '${DESTINATION_PATH}/ndm/SACL*' '${DESTINATION_PATH}/work*' '*/SwiftNet/*/cfg*' '*/SwiftNet/*/log*' '*/SwiftNet/*/process*'< ${DESTINATION_PATH}.CDBCompressible; cpio -idvumf '${DESTINATION_PATH}/ndm/cfg*' '${DESTINATION_PATH}/ndm/SACL*' '${DESTINATION_PATH}/work*' '*/SwiftNet/*/cfg*' '*/SwiftNet/*/log*' '*/SwiftNet/*/process*'< ${DESTINATION_PATH}.CDBUncompressible"
		    fi
		else
		    if [ "`uname -s`" = "Linux" ]; then
			su root -c "gunzip ${DESTINATION_PATH}.CDBCompressible; cpio -idvumf $ABS_FILENAMES '${DESTINATION_PATH}/ndm/cfg*' '${DESTINATION_PATH}/ndm/SACL*' '${DESTINATION_PATH}/work*' '*/SwiftNet/*/cfg*' '*/SwiftNet/*/log*' '*/SwiftNet/*/process*'< ${DESTINATION_PATH}.CDBCompressible"
		    else
			su root -c "uncompress ${DESTINATION_PATH}.CDBCompressible; cpio -idvumf '${DESTINATION_PATH}/ndm/cfg*' '${DESTINATION_PATH}/ndm/SACL*' '${DESTINATION_PATH}/work*' '*/SwiftNet/*/cfg*' '*/SwiftNet/*/log*' '*/SwiftNet/*/process*'< ${DESTINATION_PATH}.CDBCompressible"
		    fi
		fi
		if [ $? -eq 0 -o $SU_ATTEMPT -gt 3 ]
		then
		    break
		else
		    echo
		    echo "root command attempt $SU_ATTEMPT failed - possibly invalid password."
		    SU_ATTEMPT=`expr $SU_ATTEMPT + 1`
		fi
	    done
	    if [ $SU_ATTEMPT -gt 3 ]
	    then
		EXIT_STATUS=1
	    fi
	fi
	rm -f ${DESTINATION_PATH}.CDB*ompressible*
	echo
	echo_nn "Would you like retain the backup file used for this restore?:[Y/n]";yes_or_no
	if [ "$YESNO" = "n" ]; then
	    rm $BACKUP_FILE
	fi
    else
	EXIT_STATUS=1
    fi

    echo
    if [ $EXIT_STATUS -ne 0 ]
    then
	echo "Restore completed, errors detected."
    else
	echo "Restore completed successfully."
    fi
    sleep 2

    exit $EXIT_STATUS

elif [ "$Install_option" = "UPGRADE" ]
then
    echo
    echo_nn "Have the $PRODUCT_FULL_NAME for UNIX Server and all installed options, such as File Agent, been stopped?:[Y/n]:";yes_or_no
    if [ "$YESNO" = "n" ]; then
	EXIT_STATUS=1
	echo
	echo "Please ensure the $PRODUCT_FULL_NAME for UNIX Server has been stopped and then rerun cdinstall."
	echo
	exit $EXIT_STATUS
    fi

    echo
    echo "Would you like to back up your existing $PRODUCT_FULL_NAME for UNIX installation before proceeding with"
    echo_nn 'the upgrade? (you will need the root password to do this):[Y/n]';yes_or_no
    if [ "$YESNO" = "y" ]; then
	INSTALLED_SPACE=`du -ks $DESTINATION_PATH 2>/dev/null | cut -d"/" -f1`
	SPACE_REQUIRED=`expr $INSTALLED_SPACE \* 2`
	echo
		#===========
		# check enough disk space is available
		#===========
	chk_free_disk "$DESTINATION_PATH" "$SPACE_REQUIRED" "backup"
	val_free_disk=$?
	if [ $val_free_disk -eq  0 ]; then
	    BACKUP_FILE=$DESTINATION_PATH.CDBackup.`date +%y%m%d`.tar
	    if [ -f "$BACKUP_FILE" ]
	    then
		echo
		echo "$PRODUCT_FULL_NAME for UNIX installation has already been backed up today.  Would you like to"
		echo_nn "remove the existing backup and create a new one?:[Y/n]";yes_or_no
		if [ "$YESNO" = "y" ]; then
		    rm "$BACKUP_FILE"
		else
		    echo
		    echo "Backup procedure aborted."
		    echo
		    echo_nn "Would you like to continue with the upgrade procedure?:[Y/n]";yes_or_no
		    if [ "$YESNO" != "y" ]; then
			EXIT_STATUS=1
		    fi
		fi
	    fi

	    if [ ! -f "$BACKUP_FILE" ]
	    then
		echo
		echo "Backup procedure may take a minute...."
		echo
		UNCOMPRESSIBLE_FILES=`find $DESTINATION_PATH -name \* -print 2>/dev/null | egrep '\.jar$|\.bin$|\.pdf$|\.gz$|\.Z$|\.gif$' | wc -l`
		SU_ATTEMPT=1
		while [ true ]; do
		    echo "Please wait for the prompt to appear and then enter the root password."
		    if [ $UNCOMPRESSIBLE_FILES -gt 0 ]
		    then
			if [ "`uname -s`" = "Linux" ]; then
			    su root -c "find $DESTINATION_PATH -name \* -print | egrep -v '\.jar$|\.bin$|\.pdf$|\.gz$|\.Z$|\.gif$' | cpio -oBv -H newc > ${DESTINATION_PATH}.CDBCompressible; gzip ${DESTINATION_PATH}.CDBCompressible; find $DESTINATION_PATH -name \* -print | egrep '\.jar$|\.bin$|\.pdf$|\.gz$|\.Z$|\.gif$' | cpio -oBv -H newc > ${DESTINATION_PATH}.CDBUncompressible"
			else
			    su root -c "find $DESTINATION_PATH -name \* -print | egrep -v '\.jar$|\.bin$|\.pdf$|\.gz$|\.Z$|\.gif$' | cpio -oBv > ${DESTINATION_PATH}.CDBCompressible; compress ${DESTINATION_PATH}.CDBCompressible; find $DESTINATION_PATH -name \* -print | egrep '\.jar$|\.bin$|\.pdf$|\.gz$|\.Z$|\.gif$' | cpio -oBv > ${DESTINATION_PATH}.CDBUncompressible"
			fi
		    else
			if [ "`uname -s`" = "Linux" ]; then
			    su root -c "find $DESTINATION_PATH -name \* -print | cpio -oBv -H newc > ${DESTINATION_PATH}.CDBCompressible; gzip ${DESTINATION_PATH}.CDBCompressible"
			else
			    su root -c "find $DESTINATION_PATH -name \* -print | cpio -oBv > ${DESTINATION_PATH}.CDBCompressible; compress ${DESTINATION_PATH}.CDBCompressible"
			fi
		    fi
		    if [ $? -eq 0 -o $SU_ATTEMPT -gt 3 ]
		    then
			break
		    else
			echo
			echo "root command attempt $SU_ATTEMPT failed - possibly invalid password."
			SU_ATTEMPT=`expr $SU_ATTEMPT + 1`
		    fi
		done
		if [ $SU_ATTEMPT -gt 3 ]
		then
		    echo
		    echo "Backup procedure aborted."
		    echo
		    echo_nn "Would you like to continue with the upgrade procedure?:[Y/n]";yes_or_no
		    if [ "$YESNO" != "y" ]; then
			EXIT_STATUS=1
		    fi
		else
		    if [ "`uname -s`" = "Linux" ]; then
			tar cvfP - ${DESTINATION_PATH}.CDB*ompressible* > $BACKUP_FILE
		    else
			tar cvf - ${DESTINATION_PATH}.CDB*ompressible* > $BACKUP_FILE
		    fi
		    rm -f ${DESTINATION_PATH}.CDB*ompressible*
		    echo
		    echo "Backup procedure complete."
		    sleep 2
		fi
	    fi
	else
	    echo
	    echo "Backup procedure aborted."
	    echo
	    echo_nn "Would you like to continue with the upgrade procedure?:[Y/n]";yes_or_no
	    if [ "$YESNO" != "y" ]; then
		EXIT_STATUS=1
	    fi
	fi
    fi

    if [ $EXIT_STATUS -eq 0 ]
    then
	$CLEAR
	echo "Upgrading installed features..."

	if [ ! -f "$DESTINATION_PATH/ndm/bin/direct" ]; then
	    echo
	    echo "Server only installation detected"
	    echo
	    install_server
	    if [ "$cdai_debug" != "y" ]; then
		${DESTINATION_PATH}/etc/cdcust $Install_option
	    else
		$cdai_deployDir/cdcust $Install_option
	    fi
	    echo
	    echo "Server only upgrade completed"
	    echo
	    sleep 2
	elif [ ! -f "$DESTINATION_PATH/ndm/bin/cdpmgr" ]; then
	    echo
	    echo "Client only installation detected"
	    echo
	    install_cliapi "$DESTINATION_PATH" "$Device" "$Hostname"
	    echo
	    echo "Client only upgrade completed"
	    echo
	    sleep 2
	else
	    echo
	    echo "Server and Client installation detected"
	    echo
	    install_server_and_cliapi
	    if [ "$cdai_debug" != "y" ]; then
		${DESTINATION_PATH}/etc/cdcust $Install_option
	    else
		$cdai_deployDir/cdcust $Install_option
	    fi
	    echo
	    echo "Server and Client upgrade completed"
	    echo
	    sleep 2
	fi

	if [ $EXIT_STATUS -eq 0 ]; then
            func_create_ILMT_file
        fi

	if [ $EXIT_STATUS -eq 0 ]; then
	    install_file_agent "$DESTINATION_PATH" "$Device" "$Hostname"
        fi

	if [ $EXIT_STATUS -eq 0 ]; then
            if [ -d "$DESTINATION_PATH/ndm/secure+" ]
	    then
                SECURE_UPGRADE=1
                invoke_secure_plus
                EXIT_STATUS=$?
	    else
		rm -f "$DESTINATION_PATH/ndm/lib/libcdsea.so"
            fi
	fi
    fi

    echo
    if [ $EXIT_STATUS -ne 0 ]
    then
	echo "Upgrade completed, errors detected."
    else
	echo "Upgrade completed successfully."
    fi
    sleep 2

    exit $EXIT_STATUS

else # Install_option something new

    $CLEAR
    trap verify_is_safe_to_exit_trap 2 3
    while [ true ]; do
	MAIN_MENU=0
		#============
		# do the installation
		#============
	case "$Install_option" in

	    SVR_CLI)
		echo
		echo "Both $PRODUCT_FULL_NAME for UNIX Server and Client(CLI/API) Version ${PROD_VERSION}"
		echo_nn "will be installed in your system. Do you want to continue?:[Y/n]"
		yes_or_no
		if [ "$YESNO" = "y" ]; then
		    install_server_and_cliapi
		    func_create_ILMT_file
		else
		    echo
		    MAIN_MENU=1
		fi
		;;

	    SVR_ONLY)
		echo
		echo "$PRODUCT_FULL_NAME for UNIX Server Version ${PROD_VERSION} will be"
		echo_nn "installed in your system. Do you want to continue?:[Y/n]"
		yes_or_no
		if [ "$YESNO" = "y" ]; then
		    install_server
		    func_create_ILMT_file
		else
		    echo
		    MAIN_MENU=1
		fi
		;;

	    CLI_ONLY)
		echo
		echo "$PRODUCT_FULL_NAME for UNIX Client(CLI/API) Version ${PROD_VERSION} will be"
		echo_nn "installed in your system. Do you want to continue?:[Y/n]"
		yes_or_no
		if [ "$YESNO" = "y" ]; then
		    install_cliapi "$DESTINATION_PATH" "$Device" "$Hostname"
		    func_create_ILMT_file
		else
		    echo
		    MAIN_MENU=1
		fi
		;;

	    FILE_AGENT)
		echo
		echo    "$PRODUCT_FULL_NAME for UNIX File Agent will be installed"
		echo_nn "in your system. Do you want to continue?:[Y/n]"
		yes_or_no
		if [ "$YESNO" = "y" ]; then
		    install_file_agent "$DESTINATION_PATH" "$Device" "$Hostname"
		else
		    echo
		    MAIN_MENU=1
		fi
		;;

			# 3.8 get secure+ install script and invoke it to install secure+
	    SECURE_OPTION)
		SECURE_UPGRADE=
		invoke_secure_plus
		;;

	    SNMP_AGENT)
		echo
		echo "$PRODUCT_FULL_NAME for UNIX SNMP Agent $PROD_VERSION will be"
		echo "installed on your system."
		echo
		echo "Do you want to continue?:[Y/n]"
		yes_or_no
		if [ "$YESNO" = "y" ]; then
		    if [ "X$Device" != "X" ]; then
			echo "Extracting SNMP Agent Install Script...."
			cpio -civdmB snmpinstall < $Device 2>/dev/null
		    else
			echo "Extract SNMP Agent Install Script (snmpinstall)."
			break;
		    fi
		    if [ -f ./snmpinstall ]; then
			sleep 2;sh snmpinstall "$DESTINATION_PATH" "$Device" "$Hostname"
		    else
			echo "Extract SNMP Agent Install Script (snmpinstall) and reissue"
			echo cdinstall.
		    fi
		else
		    echo
		    MAIN_MENU=1
		fi
		;;

	    EXIT_SCRIPT)
                verify_is_safe_to_exit
                # If that call didn't exit(), then they want back to the main menu.
		$CLEAR
		set_install_option
                continue
		;;
	esac

# 3.8		if [  "$Install_option" != SNMP_AGENT -a \( "$MAIN_MENU" -eq 0 \) -a \( "$Install_option" != "FILE_AGENT" \)  ]; then
	if [  "$Install_option" != SNMP_AGENT -a \( "$MAIN_MENU" -eq 0 \) -a \( "$Install_option" != "FILE_AGENT" -a "$Install_option" != SECURE_OPTION \)  ]; then
			#============
			# clean up
			#============

			#============
			# Set permission for the work directory
			#============
	    if [ -d ${DESTINATION_PATH}/work ]; then
		chmod 1775 ${DESTINATION_PATH}/work
	    fi

			#================
			# Set permissions for the authenticator to make it secure
			#================
			#
			# security directory is set accessible only by owner
	    if [ -d ${DESTINATION_PATH}/ndm/security ]; then
		chmod 0700 ${DESTINATION_PATH}/ndm/security
	    fi

			#
			# authenticator runs as a setuid program
	    if [ -f ${DESTINATION_PATH}/ndm/bin/ndmauths ]; then
		chmod u+s ${DESTINATION_PATH}/ndm/bin/ndmauths
	    fi

	    if [ -f ${DESTINATION_PATH}/ndm/bin/ndmauthc ]; then
		chmod u+s ${DESTINATION_PATH}/ndm/bin/ndmauthc
	    fi

			#
			# For security, remove world execute permissions from setuid root executables
	    if [ -f ${DESTINATION_PATH}/ndm/bin/cdpmgr ]; then
		chmod o-rwx ${DESTINATION_PATH}/ndm/bin/cdpmgr
	    fi
	    if [ -f ${DESTINATION_PATH}/ndm/bin/ndmsmgr ]; then
		chmod o-rwx ${DESTINATION_PATH}/ndm/bin/ndmsmgr
	    fi
	    if [ -f ${DESTINATION_PATH}/ndm/bin/ndmcmgr ]; then
		chmod o-rwx ${DESTINATION_PATH}/ndm/bin/ndmcmgr
	    fi
	    if [ -f ${DESTINATION_PATH}/ndm/bin/ndmumgr ]; then
		chmod o-rwx ${DESTINATION_PATH}/ndm/bin/ndmumgr
	    fi
#	4.1 - remove hostid
#			if [ -f ${DESTINATION_PATH}/ndm/bin/cd_hostid -a "$SYSTEM_NAME" = "Linux" ]; then
#				chmod o-rwx ${DESTINATION_PATH}/ndm/bin/cd_hostid
#			fi

			#============
			# Do ranlib
			#============
	    (cd ${DESTINATION_PATH}/ndm/lib ; ranlib ndmapi.a)  1>/dev/null 2>&1

			#============
			# Invoke the customization procedure
			#============
	    sleep 1
			# CDCUST now returns, then exit...
	    if [ "$cdai_debug" != "y" ]; then
		${DESTINATION_PATH}/etc/cdcust
	    else
		$cdai_deployDir/cdcust
	    fi

			# Removed for File Agent support - give the user the opportunity to install the File Agent
			# exit
	fi   #Install Option is not equal to SNMP Agent


	cd $CDINST_DIR
	echo
	echo_nn "Would you like to return to the installation menu?:[Y/n]"; yes_or_no
	if [ "$YESNO" = "n" ]; then
            verify_is_safe_to_exit
	fi
        # If the user decided NOT to actually exit, go back to main menu.
	$CLEAR
	set_install_option
    done
    trap '' 2 3
fi # if upgrade
